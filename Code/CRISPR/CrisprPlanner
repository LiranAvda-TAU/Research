from Code.CRISPR.DataClasses.CodonData import CodonData
from Code.CRISPR.DataClasses.ReattachmentSection import ReattachmentSection
from Code.CRISPR.DataClasses.SequenceSites import SequenceSites
from Code.CRISPR.Enum.AminoAcid import AminoAcid
from Code.CRISPR.Enum.DNASection import DNASection
from Code.CRISPR.Enum.MutationDirection import MutationDirection
import random
import re
from statistics import mean

from Code.CRISPR.Enum.RestrictionSiteType import RestrictionSiteType
from Code.Utils.BioPython import BioPython


class CrisprPlanner:
    possibilities = {'A': 'C', 'C': 'T', 'T': 'G', 'G': 'A'}

    codon_dic = {'A': {'GCT', 'GCC', 'GCA', 'GCG'}, 'C': {'TGT', 'TGC'}, 'D': {'GAT', 'GAC'}, 'E': {'GAA', 'GAG'},
                 'F': {'TTT', 'TTC'}, 'G': {'GGT', 'GGC', 'GGA', 'GGG'}, 'H': {'CAT', 'CAC'},
                 'I': {'ATT', 'ATC', 'ATA'}, 'K': {'AAA', 'AAG'}, 'L': {'TTA', 'TTG', 'CTT', 'CTC', 'CTA', 'CTG'},
                 'M': {'ATG'}, 'N': {'AAT', 'AAC'}, 'P': {'CCT', 'CCC', 'CCA', 'CCG'}, 'Q': {'CAA', 'CAG'},
                 'R': {'CGT', 'CGC', 'CGA', 'CGG', 'AGA', 'AGG'}, 'S': {'TCT', 'TCC', 'TCA', 'TCG', 'AGT', 'AGC'},
                 'T': {'ACT', 'ACC', 'ACA', 'ACG'}, 'V': {'GTT', 'GTC', 'GTA', 'GTG'}, 'W': {'TGG'},
                 'Y': {'TAT', 'TAC'}, 'STOP': {'TAA', 'TAG', 'TGA'}}

    amino_acid_dic = {'GCT': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A', 'TGT': 'C', 'TGC': 'C', 'GAT': 'D', 'GAC': 'D',
                      'GAA': 'E', 'GAG': 'E', 'TTT': 'F', 'TTC': 'F', 'GGT': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G',
                      'CAT': 'H', 'CAC': 'H', 'ATT': 'I', 'ATC': 'I', 'ATA': 'I', 'AAA': 'K', 'AAG': 'K', 'TTA': 'L',
                      'TTG': 'L', 'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L', 'ATG': 'M', 'AAT': 'N', 'AAC': 'N',
                      'CCT': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P', 'CAA': 'Q', 'CAG': 'Q', 'CGT': 'R', 'CGC': 'R',
                      'CGA': 'R', 'CGG': 'R', 'AGA': 'R', 'AGG': 'R', 'TCT': 'S', 'TCC': 'S', 'TCA': 'S', 'TCG': 'S',
                      'AGT': 'S', 'AGC': 'S', 'ACT': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T', 'GTT': 'V', 'GTC': 'V',
                      'GTA': 'V', 'GTG': 'V', 'TGG': 'W', 'TAT': 'Y', 'TAC': 'Y', 'TAA': 'STOP', 'TAG': 'STOP',
                      'TGA': 'STOP'}

    codon_usage = {'UUU': 23.3, 'UCU': 16.7, 'UAU': 17.5, 'UGU': 11.2, 'UUC': 23.9, 'UCC': 10.6, 'UAC': 13.7,
                   'UGC': 9.1,
                   'UUA': 9.8, 'UCA': 20.6, 'UAA': 1.6, 'UGA': 1.4, 'UUG': 20.0, 'UCG': 12.2, 'UAG': 0.6, 'UGG': 11.1,
                   'CUU': 21.2, 'CCU': 8.8, 'CAU': 14.1, 'CGU': 11.2, 'CUC': 14.8, 'CCC': 4.4, 'CAC': 9.2, 'CGC': 5.1,
                   'CUA': 7.9, 'CCA': 26.1, 'CAA': 27.4, 'CGA': 12.1, 'CUG': 12.1, 'CCG': 9.7, 'CAG': 14.4, 'CGG': 4.7,
                   'AUU': 32.2, 'ACU': 18.9, 'AAU': 30.2, 'AGU': 12.1, 'AUC': 18.9, 'ACC': 10.4, 'AAC': 18.3,
                   'AGC': 8.4,
                   'AUA': 9.5, 'ACA': 20.0, 'AAA': 37.5, 'AGA': 15.4, 'AUG': 26.1, 'ACG': 8.9, 'AAG': 25.8, 'AGG': 4.0,
                   'GUU': 24.1, 'GCU': 22.4, 'GAU': 35.8, 'GGU': 10.9, 'GUC': 13.6, 'GCC': 12.6, 'GAC': 17.1,
                   'GGC': 6.7,
                   'GUA': 9.8, 'GCA': 19.8, 'GAA': 40.8, 'GGA': 31.7, 'GUG': 14.3, 'GCG': 8.2, 'GAG': 24.5, 'GGG': 4.4}

    restriction_sites = ['ACCGGT', 'GTGCAC', 'ATTAAT', 'GGATCC', 'AGATCT', 'ATCGAT', 'GAATTC', 'GATATC', 'AGCGCT',
                         'GGCGCT', 'AGCGCC', 'GGCGCC', 'AAGCTT', 'GGTGA', 'GGTACC', 'TGGCCA', 'CCATGG', 'CATATG',
                         'GCTAGC', 'GCGGCCGC', 'CTGCAG', 'CAGCTG', 'GAGCTC', 'CCTGCAGG', 'TACGTA', 'ACTAGT',
                         'TCTAGA', 'CTCGAG', 'CCCGGG', 'AATT', 'GTAC', 'TCGA', 'GATC', 'CCGG']

    def __init__(self, gene_name, aa_mutation_site, sense_strand, amino_acid_sequence: str = ""):
        self.gene_name = gene_name
        self.sense_strand = sense_strand
        self.anti_sense_strand = CrisprPlanner.get_anti_sense_strand(sense_strand)
        self.amino_acid_sequence = amino_acid_sequence if amino_acid_sequence else \
            BioPython.get_aa_seq_by_c_elegans_gene_name(gene_name)
        self.amino_acid_mutation_site = aa_mutation_site
        self.sense_mutation_site = -1
        self.anti_sense_mutation_site = -1

    def get_relevant_strand(self, direction):
        if direction > 0:
            return self.sense_strand
        else:
            return self.anti_sense_strand

    def plan_my_crispr(self, from_aa: AminoAcid,
                       to_aa: AminoAcid,
                       check_consistency: bool = False,
                       window_size: int = 30,
                       PAM_size: int = 3):
        print("Gene's sense sequence:", self.sense_strand)
        print("Gene's amino acid sequence: ", self.amino_acid_sequence)
        self.sense_mutation_site = self.find_site_in_nt_seq(amino_acid_site=self.amino_acid_mutation_site,
                                                            check_sequence_consistency=check_consistency)
        print("mutation site in sense strand is: " + str(self.sense_mutation_site), ", and the codon is:",
              self.sense_strand[self.sense_mutation_site:self.sense_mutation_site + 3])
        self.anti_sense_mutation_site = self.get_mutation_site_for_anti_sense(self.sense_mutation_site)
        print("mutation site in anti-sense strand: " + str(self.anti_sense_mutation_site))

        # get optional sequences for crRNA
        sense_strand_sequences = CrisprPlanner.get_list_of_potential_sequences(self.sense_strand,
                                                                               self.sense_mutation_site,
                                                                               window_size,
                                                                               PAM_size)
        anti_sense_strand_sequences = CrisprPlanner. \
            get_list_of_potential_sequences(self.anti_sense_strand,
                                            self.anti_sense_mutation_site,
                                            window_size,
                                            PAM_size)
        print("Sense crRNAs: ")
        for sequence in sense_strand_sequences:
            print(sequence)
            pam_site_start = sequence[1][1]
            pam_site_end = sequence[1][1] + 3
            print("PAM sequence: " + self.sense_strand[pam_site_start:pam_site_end])
        print("Anti Sense crRNAs: ")
        for sequence in anti_sense_strand_sequences:
            print(sequence)
            pam_site_start = sequence[1][1]
            pam_site_end = sequence[1][1] + 3
            print("PAM sequence: " + self.anti_sense_strand[pam_site_start:pam_site_end])

        chosen_crrna, strand_direction = CrisprPlanner.choose_best_crrna(sense_strand_sequences,
                                                                         anti_sense_strand_sequences)
        # now we have our cr_rna
        print("chosen crRNA: " + str(chosen_crrna))
        strand_str = "anti-" if strand_direction < 0 else ""
        print("The relevant strand is " + strand_str + "sense")

        pam_site_start = chosen_crrna[1][1]
        pam_site_end = chosen_crrna[1][1] + 2
        pam_sites = (pam_site_start, pam_site_end)

        ssODN_strand_direction, mutation_direction = CrisprPlanner. \
            choose_ssODN_strand(self.sense_mutation_site if strand_direction > 0 else self.anti_sense_mutation_site,
                                strand_direction,
                                pam_site_start)
        print("Mutation direction is:", str(mutation_direction), "thus ssODN direction is:",
              str(ssODN_strand_direction))
        if ssODN_strand_direction != strand_direction:
            print("The ssODN is on the opposite strand!")
            # ssODN is not on the strand from which we got the crRNA, thus we need to find its pam sites again
            pam_sites = (self.find_index_in_parallel_strand(pam_site_end),
                         self.find_index_in_parallel_strand(pam_site_start))
            print("pam sites on the ssODN strand:", pam_sites)

        # to be mutated
        mutated_strand = self.sense_strand if ssODN_strand_direction > 0 else self.anti_sense_strand
        ssODN_mutation_codon = self.sense_mutation_site if ssODN_strand_direction > 0 else self.anti_sense_mutation_site

        # getting the zone where all mutations will be located: after to before DSB
        mutations_zone = self.get_mutations_zone(mutation_direction, pam_sites)
        # sanity check
        print("mutation codon is at", ssODN_mutation_codon, "and mutations zone is", str(mutations_zone))

        # 1. mutation to change codon
        mutated_strand, codon_mutated_sites = self.apply_codon_mutation(mutated_strand, ssODN_mutation_codon,
                                                                        self.get_demands(from_aa, to_aa,
                                                                                         self.sense_mutation_site))

        # making sure that the strand is good so far
        print("mutated strand after adding codon mutation:", mutated_strand)
        print("sites changed:", codon_mutated_sites)

        # 2. mutations to change nt to prevent re-attachments - in PAM or crRNA sequence
        # if mutation is DOWNSTREAM the section to be changed is PAM site, if UPSTREAm - crRNA.
        if mutation_direction == MutationDirection.DOWNSTREAM:
            section_to_mutate = ReattachmentSection(DNASection.PAM_SITE, SequenceSites(pam_sites[0], pam_sites[1]), 1)
        else:
            section_to_mutate = ReattachmentSection(DNASection.CR_RNA, SequenceSites(pam_sites[0] - 20, pam_sites[0] -6), 4)
        print("section to mutate to prevent re-attachment:", section_to_mutate.section_sites, "in",
              section_to_mutate.section_type)
        CrisprPlanner.prevent_reattachment(section_to_mutate, ssODN_mutation_codon, mutated_strand, mutation_direction,
                                           codon_mutated_sites)
        # mutated_strand, mutated_sites = self.apply_mutation(mutated_strand, mutation_direction, mutations_zone,
        #                                                     pam_sites, codon_mutated_sites)

        # 3. mutations to add/remove restriction sites
        print("Add or Remove restriction sites:")
        self.add_remove_restriction_sites(mutated_strand, mutations_zone, ssODN_strand_direction,
                                          codon_mutated_sites, mutation_direction, pam_sites)


        #
        # pam_site_mutated = self.check_if_pam_site_mutated(mutated_sites, pam_sites)
        # if not pam_site_mutated:
        #     mutated_strand = self.mutate_pam_site(mutated_strand, )
        # print("pam sites inside: " + str(pam_sites) + ", mutation site: " + str(ssODN_mutation_codon-1))
        # print("pam sites for opposite strand: " + str(pam_site_start), str(pam_site_end))

    # receives (1) the section that needs to be mutated to prevent reattachment, (2) the indexes of the amino acid's
    # mutation codon on the ssODN strand, (3) the mutated strand,(4) the mutation direction, and (4) the sites that have
    #  changed while mutating the amino acid, computes which indexes can be changed in order to insert the section with
    # silent mutations and returns the strand with the new mutations
    @staticmethod
    def prevent_reattachment(section_to_mutate: ReattachmentSection, ssODN_mutation_codon, mutated_strand,
                             mutation_direction, codon_mutated_sites):
        # format of codons_data: ('GCG', (1, 3))
        codons_data = CrisprPlanner.get_relevant_codons(section_to_mutate, ssODN_mutation_codon, mutated_strand)
        possible_mutations = []
        for codon_data in codons_data:
            # all codons_data that translate to the same amino acid as the relevant codon does
            same_aa_codons = list(CrisprPlanner.get_similar_codons(codon_data.codon))

            if section_to_mutate.section_type == DNASection.PAM_SITE:
                # removes PAM mutations of sequence NGA and NGG
                CrisprPlanner.check_PAM_mutation(codon_data, same_aa_codons, section_to_mutate, mutation_direction)
            # removes codons that run over the nucleotide change to change amino acid
            CrisprPlanner.check_already_mutated_sites(codon_data, same_aa_codons, codon_mutated_sites)

            # the codon that it is easiest to mutate into, and the detail required to do so, such as: ('GCG', (1, {0: 'G'}, 8.2))
            mutated_codon_details = CrisprPlanner.how_to_get_b_codons_from_a(codon_data.codon, same_aa_codons)
            if mutated_codon_details:
                possible_mutations.append((codon_data, mutated_codon_details))
        possible_mutations.sort(key=lambda x: abs(x[0].codon_sites.start-mean(codon_mutated_sites)))

        number_of_mutants = CrisprPlanner.get_number_of_mutants(section_to_mutate, codon_mutated_sites)

        try:
            chosen_mutations = possible_mutations[:number_of_mutants]
        except:
            chosen_mutations = possible_mutations
        print("mutated codons details:")
        for mutated_codon_details in chosen_mutations:
            print(mutated_codon_details)

    # Takes into consideration whether mutations to change amino acid have also modified the reattachment sequence, and
    # thus we need fewer mutatnt to introduce to the reattachment squence
    @staticmethod
    def get_number_of_mutants(section_to_mutate, codon_mutated_sites):
        number_of_mutants = section_to_mutate.number_of_mutations
        extra = 0 if section_to_mutate.section_type == DNASection.PAM_SITE else 2
        for mutated_site in codon_mutated_sites:
            if section_to_mutate.section_sites.start <= mutated_site <= section_to_mutate.section_sites[1] + extra:
                number_of_mutants -= 1
                print("already a mutant in nucleotide:", mutated_site)
        if number_of_mutants < 0:
            number_of_mutants = 0
        return number_of_mutants

    # receives (1) codon_data the contains the codon and its sites, (2) possible codons that the former codons could be
    # mutated into but keep the amino acid, and (3) sites that have changed and the new mutations shouldn't run over.
    # The function goes through each of the mutated site (input 3) and checks if it is inside the range of the new
    # codon sites. If so, it checks whether in the possible codons list there are codons that run over that site (change
    #  nucleotide), and if there are, removes them from the possible codons list.
    @staticmethod
    def check_already_mutated_sites(codon_data, possible_codons, codon_mutated_sites):
        for codon_mutated_site in codon_mutated_sites:
            if codon_data.codon_sites.start <= codon_mutated_site <= codon_data.codon_sites.end:
                for possible_codon in possible_codons:
                    # mutated_codon_details format = (1, {2: 'G'}, 14.3)
                    mutated_codon_details = CrisprPlanner.how_to_get_b_codons_from_a(codon_data.codon, [possible_codon])[1]
                    for key in mutated_codon_details[1].keys():
                        # for each nucleotide mutation, key is the nucleotide place in the codon: 0,1,2
                        if codon_data.codon_sites[0]+key == codon_mutated_site:
                            print("codon", possible_codon, "in", mutated_codon_details, codon_data.codon_sites, "removed")
                            possible_codons.remove(possible_codon)
                            break

    # receives (1) list of mutations to check, (2) list of possible codons in that site, (3) section to mutate (PAM site
    #  or crRNA and the details), and (4) mutation direction (upstream or downstream) and checks if one of the PAM
    # mutations is substituting NGG site with an NGA or NGG site, and if so, removes it from the valid list of codons
    # returned.
    @staticmethod
    def check_PAM_mutation(codon_data: CodonData, possible_codons, section_to_mutate, mutation_direction):

        if codon_data.codon_sites.start < section_to_mutate.section_sites.start:
            # before beginning of PAM site
            if codon_data.codon_sites.end == section_to_mutate.section_sites.end:
                # only contains first nucleotide
                if mutation_direction == MutationDirection.DOWNSTREAM:
                    # cannot be T to prevent NGA
                    for possible_codon in possible_codons[:]:
                        if possible_codon[0] == 'T':
                            print("possible codon removed:", possible_codon, "in", codon_data)
                            possible_codons.remove(possible_codon)
                else:
                    # mutation only changes the N part of NGG PAM site - not useful
                    possible_codons.clear()
            elif codon_data.codon_sites.end > section_to_mutate.section_sites.start:
                # contains first two amino acids
                if mutation_direction == MutationDirection.DOWNSTREAM:
                    for possible_codon in possible_codons[:]:
                        if possible_codon[1:] == 'TC':
                            print("possible codon removed:", possible_codon, "in", codon_data)
                            possible_codons.remove(possible_codon)
        elif codon_data.codon_sites == section_to_mutate.section_sites:
            for possible_codon in possible_codons[:]:
                if mutation_direction == MutationDirection.UPSTREAM:
                    # the site is NGG
                    if possible_codon[1:] == 'GA':
                        print("possible codon removed:", possible_codon, "in", codon_data)
                        possible_codons.remove(possible_codon)
                else:
                    # the site is CCN
                    if possible_codon[:2] == 'TC':
                        print("possible codon removed:", possible_codon, "in", codon_data)
                        possible_codons.remove(possible_codon)
        else:
            if codon_data.codon_sites.start < section_to_mutate.section_sites.end:
                # contains two last amino acids
                if mutation_direction == MutationDirection.UPSTREAM:
                    for possible_codon in possible_codons[:]:
                        if possible_codon[:2] == 'GA':
                            print("possible codon removed:", possible_codon, "in", codon_data)
                            possible_codons.remove(possible_codon)
            elif codon_data.codon_sites.start == section_to_mutate.section_sites.end:
                # contains only last PAM nucleotide
                if mutation_direction == MutationDirection.UPSTREAM:
                    for possible_codon in possible_codons[:]:
                        if possible_codon[0] == 'A':
                            print("possible codon removed:", possible_codon, "in", codon_data)
                            possible_codons.remove(possible_codon)
                else:
                    possible_codons.clear()

    # receives (1) a codon and returns all other codons that translated to the same amino acid
    @staticmethod
    def get_similar_codons(codon):
        amino_acid = CrisprPlanner.amino_acid_dic[codon]
        relevant_codons = CrisprPlanner.codon_dic[amino_acid].copy()
        relevant_codons.remove(codon)
        return relevant_codons

    # receives (1) the section to be mutated (PAM site or crRNA indexes), (2) the aa mutation codon indexes of the ssODN
    # strand, and (3) the mutated strand (sense or anti-sense) and returns a list of all codons and their indexes that
    # are included in the section to be mutated indexes
    # format of the results: ('GCG', (1, 3))
    @staticmethod
    def get_relevant_codons(section_to_mutate: ReattachmentSection, ssODN_mutation_codon, mutated_strand):
        codons_data = []
        remainder = abs(section_to_mutate.section_sites.start - ssODN_mutation_codon) % 3
        start = section_to_mutate.section_sites.start - remainder
        end = section_to_mutate.section_sites[1]
        # if section is crRNA, we don't want to make changes in the DSB
        while start <= end:
            codon = mutated_strand[start:start + 3]
            codons_data.append(CodonData(codon, SequenceSites(start, start + 2)))
            start += 3
        print(str(len(codons_data)), "codons:", codons_data)
        return codons_data


    # This function receives (1) an amino acid sequence site and (2) value that indicates whether to check the
    # correlation between amino acid sequence and nucleotide sequence (codon to amino acid) or not, and returns the
    # site of the mutation in the nucleotide sequence, meaning the site or the corresponding codon
    def find_site_in_nt_seq(self, amino_acid_site, check_sequence_consistency: bool = True):
        sense_without_utr = self.remove_utr()
        print("sense without utr:", sense_without_utr)
        if check_sequence_consistency:
            # consistency check
            nt_index = 0
            aa_index = 0
            while aa_index < len(self.amino_acid_sequence):
                CrisprPlanner.check_sequence_consistency(sense_without_utr[nt_index:nt_index + 3],
                                                         self.amino_acid_sequence[aa_index])
                nt_index += 3
                aa_index += 1

        nt_site_in_sense_without_utr = (amino_acid_site - 1) * 3
        utrs = 0
        seq_index = 0
        exon_index = 0
        while seq_index < len(self.sense_strand):
            if self.sense_strand[seq_index].islower():
                # region is intron or utr
                utrs += 1
            else:
                # region is exon
                exon_index += 1
                if exon_index == nt_site_in_sense_without_utr:
                    return exon_index + utrs
            seq_index += 1

    # receives (1) a codon string and (2) the relevant amino and checks if the codon translates to this amino acid
    @staticmethod
    def check_sequence_consistency(input_codon, amino_acid):
        codon_table = {'GCT': 'A', 'TGT': 'C', 'GAT': 'D', 'GAA': 'E', 'TTT': 'F', 'GGT': 'G', 'CAT': 'H',
                       'ATT': 'I', 'AAA': 'K', 'TTA': 'L', 'ATG': 'M', 'AAT': 'N', 'CCT': 'P', 'CAA': 'Q',
                       'CGT': 'R', 'TCT': 'S', 'ACT': 'T', 'GTT': 'V', 'TGG': 'W', 'TAT': 'Y', 'TTC': 'F',
                       'TTG': 'L', 'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L', 'ATC': 'I', 'ATA': 'I',
                       'GTC': 'V', 'GTA': 'V', 'GTG': 'V', 'TCC': 'S', 'TCA': 'S', 'TCG': 'S', 'CCC': 'P',
                       'CCA': 'P', 'CCG': 'P', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T', 'GCC': 'A', 'GCA': 'A',
                       'GCG': 'A', 'TAC': 'Y', 'TAA': 'STOP', 'TAG': 'STOP', 'CAC': 'H', 'CAG': 'Q', 'AAC': 'N',
                       'AAG': 'K', 'GAC': 'D', 'GAG': 'E', 'TGC': 'C', 'TGA': 'STOP', 'CGC': 'R', 'CGA': 'R',
                       'CGG': 'R', 'AGT': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R', 'GGC': 'G', 'GGA': 'G',
                       'GGG': 'G'}
        if codon_table[input_codon] != amino_acid:
            print("Instead of " + codon_table[input_codon], ", the amino acid in the sequence is " + amino_acid)

    # receives a (1) strand of nt, (2) the mutation site, (3) the window size around the mutation site where DSB point
    # can be located and (4) size of PAM sequence, checks in the strand for 20 bp sequences around the mutation size
    # that end in PAM sequence ('NGG') and returns a list of those sequences, as a tuple of the sequences and its start
    # and end indexes.
    @staticmethod
    def get_list_of_potential_sequences(strand, mutation_site, window_size, PAM_size, cr_rna_size: int = 20):
        potential_cr_rnas = []
        start_point = max(0, mutation_site - window_size + PAM_size)
        end_point = min(mutation_site + window_size + PAM_size, len(strand) - 1)
        print("start point: " + str(start_point) + ", end point: " + str(end_point))
        for i in range(start_point, end_point):
            if strand[i + 1:i + 3] == "GG":
                try:
                    potential_cr_rna = strand[i - cr_rna_size:i]
                    potential_cr_rnas.append((potential_cr_rna, (i - cr_rna_size, i)))
                except:
                    print("Not enough space for a whole crRNA, i = " + str(i))
                    continue
        return potential_cr_rnas

    # receives (1) the mutation position in the sense strand, and returns the position of this mutation in the
    # anti-sense
    def get_mutation_site_for_anti_sense(self, sense_mutation_site):
        return len(self.anti_sense_strand) - sense_mutation_site - 3

    # receives (1) the sense strand and returns its complementary, from 3' to 5'
    @staticmethod
    def get_anti_sense_strand(given_sense_strand):
        anti_sense_strand = ''
        pair_nucleotides = {'A': 'T', 'C': 'G', 'G': 'C', 'T': 'A', 'a': 't', 'c': 'g', 'g': 'c', 't': 'a'}
        for letter in given_sense_strand:
            anti_sense_strand += pair_nucleotides[letter]
        return anti_sense_strand[::-1]

    # this function gets a nucleotide sequence and adds to a dictionary all restriction sites in the sequence
    @staticmethod
    def find_restriction_sites(nt_seq, number_of_mutations, mutants, methylated: bool = False):
        restriction_sites_in_seq = {}
        for restriction_site in CrisprPlanner.restriction_sites:
            indexes = [m.start() for m in re.finditer('(?=' + restriction_site + ')', nt_seq)]
            for index in indexes:
                if restriction_site == "GGTGA":
                    if index + 8 >= len(nt_seq):
                        continue
                elif restriction_site == "GATC":
                    if not methylated:
                        continue
                restriction_sites_in_seq[(index, index + len(restriction_site))] = restriction_site
        # only if there are some restriction sites
        if restriction_sites_in_seq:
            mutants[nt_seq] = (number_of_mutations, restriction_sites_in_seq)

    # receives a (1) sequence and (2) list containing indexes of the start and end of the PAM site in the sequence,
    # for each index in the PAM sites it changes the amino acid in that index to the other 3 possible, and each
    # mutated PAM site sequence is sent to find restriction sites in
    @staticmethod
    def change_pam_site(seq, pam_sites):
        for nt_index in range(pam_sites[0], pam_sites[1] + 1):
            current_seq = seq
            # three iterations
            for i in range(3):
                current_seq = CrisprPlanner.change_char_in_string(current_seq, nt_index,
                                                                  CrisprPlanner.possibilities[current_seq[nt_index]])
                CrisprPlanner.find_restriction_sites(current_seq, 2)

    # receives (1) a sequence, (2) a dictionary of indexes that need to be occupied by a certain nucleotides,
    # (3) a dictionary of indexes that can not be occupied with certain nucleotides, (4) a tuple that contains the start
    # and end PAM sites, (5) the number of max mutation in the sequence, (6) a mutants dictionary to save all the
    # mutants and (7) the number of mutants so far, goes through all nucleotide options each index have and for each
    # combination with one mutation finds if there is a new restriction site. returns the mutants dictionary that
    # contains the mutant sequence as key and the number of mutation in the seq and a dictionary of al restriction
    # sequences and their sites in the sequence as values.
    # It's a recursive function
    @staticmethod
    def modify_seq_to_change_restriction_sites(original_seq, demands_to_be, mutants=dict(), max_mutations: int = 2,
                                               mutations_so_far: int = 0):
        if not mutations_so_far:
            # only once at the beginning
            CrisprPlanner.find_restriction_sites(original_seq, mutations_so_far, mutants)
        if max_mutations <= mutations_so_far:
            return
        for index in range(len(original_seq)):
            if index in demands_to_be:
                continue
            else:
                current_seq = original_seq
                for iteration in range(3):
                    current_seq = CrisprPlanner.change_char_in_string(current_seq, index,
                                                                      CrisprPlanner.possibilities[current_seq[index]])
                    CrisprPlanner.find_restriction_sites(current_seq, mutations_so_far + 1, mutants)
                    # recursion step
                    new_demands = demands_to_be.copy()
                    new_demands.update({index: current_seq[index]})
                    CrisprPlanner.modify_seq_to_change_restriction_sites(current_seq,
                                                                         new_demands,
                                                                         mutants,
                                                                         max_mutations,
                                                                         mutations_so_far + 1)

    @staticmethod
    def change_char_in_string(seq, position, new_char):
        lst = list(seq)
        lst[position] = new_char
        return "".join(lst)

    @staticmethod
    def choose_best_crrna(sense_options: list, anti_sense_options: list):
        num = random.uniform(0, 1)
        if num > 0.5:
            return random.choice(sense_options), 1
        else:
            return random.choice(anti_sense_options), -1

    @staticmethod
    def choose_ssODN_strand(mutation_site, strand_direction, pam_site_start):
        DSB = pam_site_start - 3
        # default assignment
        mutation_direction = MutationDirection.UPSTREAM
        print("mutation site: " + str(mutation_site) + ", pam start: " + str(pam_site_start) + ", DSB: " + str(DSB))
        if mutation_site > DSB:
            mutation_direction = MutationDirection.DOWNSTREAM
        elif mutation_site < DSB:
            mutation_direction = MutationDirection.UPSTREAM
        if mutation_direction == MutationDirection.DOWNSTREAM:
            return -1 * strand_direction, mutation_direction
        else:
            return strand_direction, mutation_direction

    def find_index_in_parallel_strand(self, index):
        return len(self.sense_strand) - index - 1

    # this function will return the minimal nucleotides you need to change (and the range of options for change) in
    # order to get from codon a to amino acid b
    @staticmethod
    def how_to_get_b_from_a(a_codon, b: AminoAcid):
        b_codons = CrisprPlanner.codon_dic[b.value]
        return CrisprPlanner.how_to_get_b_codons_from_a(a_codon, b_codons)

    # this function will return the minimal nucleotides you need to change (and the range of options for change) in
    # order to get from codon a to possible codons b. result in format: ('GCG', (1, {0: 'G'}, 8.2))
    @staticmethod
    def how_to_get_b_codons_from_a(a_codon, b_codons):
        min_distance = 4
        options = {}
        for b_codon in b_codons:
            distance, demands = CrisprPlanner.codon_distance(a_codon, b_codon)
            if distance < min_distance:
                options = {}
                min_distance = distance
                options[b_codon] = (distance, demands, CrisprPlanner.codon_usage[CrisprPlanner.change_t_to_u(b_codon)])
            elif distance == min_distance:
                options[b_codon] = (distance, demands, CrisprPlanner.codon_usage[CrisprPlanner.change_t_to_u(b_codon)])
        if options:
            # result is a tuple of codon, details
            return CrisprPlanner.get_codon_with_higher_usage(options)
        return None

    @staticmethod
    def codon_distance(a, b):
        distance = 0
        demands = {}
        for i in range(3):
            if a[i] != b[i]:
                distance += 1
                demands[i] = b[i]
        return distance, demands

    @staticmethod
    def change_t_to_u(codon):
        new_codon = ""
        for nt in codon:
            if nt == 'T':
                new_codon += 'U'
            else:
                new_codon += nt
        return new_codon

    # gets a dictionary of options, such that the keys are tuples of the original codon (doesn't change) and new, and
    # the values are 3-tuples which consists of the number of mutations, the instructions and the usage percentage, and
    # returns the key tuple with the highest codon usage
    @staticmethod
    def get_codon_with_higher_usage(codon_options):
        max_codon = ""
        max_usage = 0
        for codon in codon_options.keys():
            value = codon_options[codon]
            usage = value[2]
            if usage > max_usage:
                max_usage = usage
                max_codon = codon
        return max_codon, codon_options[max_codon]

    def get_demands(self, a: AminoAcid, b: AminoAcid, mutation_site):
        sense_codon = self.sense_strand[mutation_site:mutation_site + 3]
        codon_options = self.codon_dic[a.value]
        if sense_codon not in codon_options:
            print(f'Codon in mutation site {mutation_site}: {sense_codon} does not translate into {a}')
            exit()
        b_codon, values = CrisprPlanner.how_to_get_b_from_a(sense_codon, b)
        demands = values[1]
        print("change", sense_codon, "to", b_codon, "with demands:", str(demands))

        return demands

    # receives (1) the strand to be mutated, (2) the mutation site in the strand (internal indexing), and (3) the
    # demands to make the change with indexes in respect to the codon, not the strand (so, 0, 1, 2...) and returns the
    # mutated strand
    @staticmethod
    def apply_codon_mutation(strand, mutation_site, demands):
        mutated_sites = []
        for index in demands.keys():
            nt = demands[index]
            position = mutation_site + int(index)
            mutated_sites.append(position)
            strand = CrisprPlanner.change_char_in_string(strand, position, nt)
        return strand, mutated_sites

    @staticmethod
    def check_if_pam_site_mutated(mutated_sites: list, pam_sites: tuple):
        pam_site_mutated = False
        for mutated_site in mutated_sites:
            if pam_sites[0] <= mutated_site <= pam_sites[1]:
                pam_site_mutated = True
                break

        if pam_site_mutated:
            print("pam site mutated")
        else:
            print("pam site not mutated")
        return pam_site_mutated

    # receives (1) the mutation direction (UPSTREAM or DOWNSTREAM) and (2) the pam sites and according to the scheme
    # that shows that for UPSRTREAM mutations, the homology arm that can undergo changes is from the DSB and for
    # DOWNSTREAM mutations, the homology arm that can undergo changes is up until the DSB, returns the right zone of
    # 10 nt. The range is open
    @staticmethod
    def get_mutations_zone(mutation_direction, pam_sites):

        if mutation_direction == MutationDirection.UPSTREAM:
            # untouched homology arm is until DSB
            DSB = pam_sites[0] - 3
        else:
            # untouched homology arm is after DSB
            DSB = pam_sites[1] + 4
        return DSB - 15, DSB

    # TBD - change the name of the mutation
    # receives (1) the strand to be mutated, (2) the direction of the mutation to understand whether to mutate the PAM
    # site or the crRNA sequence, (3) the zone in which mutations can be located, (4) the pam sites, (5) the indexes
    # in which mutations have already been located and thus can't be changed, and (6-optional) the number of mutations
    # to insert and returns the mutated strand and the indexes of the mutations
    @staticmethod
    def apply_mutation(mutated_strand, mutation_direction, mutations_zone, pam_sites, codon_mutated_sites,
                       number_of_mutations: int = 2):
        if mutation_direction == MutationDirection.UPSTREAM:
            # change crRNA
            cr_rna_sites_without_dsb = (pam_sites[0] - 1 - 20, pam_sites[0] - 1 - 3)
            print("crRNA sites without DSB:", cr_rna_sites_without_dsb)
            i = 0
            indexes = []
            while i < number_of_mutations:
                index = random.randrange(cr_rna_sites_without_dsb[0], cr_rna_sites_without_dsb[1])
                # make sure that the chosen place will create a silent mutant, third place in the codon
                if index % 3 == 2 and index not in indexes and index not in codon_mutated_sites:
                    if CrisprPlanner.is_within_mutation_zone(mutations_zone, index):
                        indexes.append(index)
                        i += 1
                        # now we have indexes to mutate
                        # todo
        # change PAM sites
        else:
            mutated_strand = mutated_strand
            # CrisprPlanner.check_if_pam_site_mutated()
            # todo
        return mutated_strand, {}

    @staticmethod
    def is_within_mutation_zone(mutation_zone, place):
        if mutation_zone[0] < place < mutation_zone[1]:
            return True
        else:
            return False

    def add_remove_restriction_sites(self, mutated_strand, mutations_zone, ssODN_direction, codon_mutated_sites,
                                     mutation_direction, pam_sites):
        # first check if the mutated strand so far (with codon mutations) has different number of restriction sites
        # than the original one
        restrictions_sites_in_original_seq = {}
        if ssODN_direction > 0:
            original_sequence = self.sense_strand[mutations_zone[0] + 1:mutations_zone[1]]
        else:
            original_sequence = self.anti_sense_strand[mutations_zone[0] + 1:mutations_zone[1]]
        self.find_restriction_sites(original_sequence, 0, restrictions_sites_in_original_seq)
        print("restrictions sites in original seq:", restrictions_sites_in_original_seq)

        restrictions_sites_in_mutated_seq = {}
        mutated_sequence = mutated_strand[mutations_zone[0] + 1:mutations_zone[1]]
        self.find_restriction_sites(mutated_sequence, len(codon_mutated_sites), restrictions_sites_in_mutated_seq)
        print("restrictions sites in mutated seq:", restrictions_sites_in_mutated_seq)

        if not self.do_restriction_sites_dictionaries_match(restrictions_sites_in_original_seq[original_sequence],
                                                            restrictions_sites_in_mutated_seq[mutated_sequence]):
            print("dictionaries don't match!")
            # the different restriction sites
            rest_sites = self.find_extra_restriction_sites(restrictions_sites_in_original_seq[original_sequence],
                                                           restrictions_sites_in_mutated_seq[mutated_sequence])
        else:
            # dictionaries match
            print("let's modify some sites!")
            modified_sequences = {}
            self.modify_seq_to_change_restriction_sites(mutated_sequence,
                                                        self.create_demands(mutated_strand, codon_mutated_sites),
                                                        modified_sequences)
            print(str(len(modified_sequences)), "have been found:", modified_sequences)

            # now we get the sequence with the chosen new restriction sites
            chosen_seq = self.find_best_sequence(modified_sequences,
                                                 restrictions_sites_in_mutated_seq,
                                                 mutated_sequence,
                                                 mutation_direction,
                                                 pam_sites)

            # find the restriction sites that both sequences don't share
            rest_sites = self.find_extra_restriction_sites(restrictions_sites_in_mutated_seq[mutated_sequence],
                                                           modified_sequences[chosen_seq])
        print("restriction sites changed:", str(rest_sites))

    # gets two dictionaries' values of the format of: (0, {(3, 9): 'TCTAGA'}) and checks if both
    # dictionaries have the same restriction sites
    @staticmethod
    def do_restriction_sites_dictionaries_match(d1_values, d2_values):
        d1_restriction_sites = d1_values[1]
        d2_restriction_sites = d2_values[1]
        if len(d1_restriction_sites) != len(d2_restriction_sites):
            return False
        else:
            for restriction_index in d1_restriction_sites:
                if restriction_index not in d2_restriction_sites:
                    return False
                elif restriction_index in d2_restriction_sites:
                    if d1_restriction_sites[restriction_index] != d2_restriction_sites[restriction_index]:
                        return False
        return True

    # receives (1) the mutated strand and (2) the indexes in which changes have been made and returns a dictionary of
    # the indexes as keys and char in that index in the mutated strand as values
    @staticmethod
    def create_demands(mutated_strand, codon_mutated_sites):
        demands = {}
        for index in codon_mutated_sites:
            demands[index] = mutated_strand[index]
        return demands

    # receives the original sequence (with only codon mutations) and the optional sequence with more mutations that has
    # more\less restrictions sites than the original, and returns the added restriction site and indexes, and whether
    # the change is added restriction site or removed. format: (2, {'TCGA': (19, 23), 'CCGG': (0, 4)})
    @staticmethod
    def find_extra_restriction_sites(mutated_seq_restriction_sites, optioal_seq_restriction_sites):
        extra_restrictions_sites = {}
        mutations_in_mutated, restriction_seqs_found_in_mutated = mutated_seq_restriction_sites
        mutations_in_optional, restriction_seqs_found_in_optional = optioal_seq_restriction_sites

        # restriction site was removed
        for restriction_index in restriction_seqs_found_in_mutated:
            if restriction_index not in restriction_seqs_found_in_optional or restriction_seqs_found_in_mutated[
                restriction_index] != restriction_seqs_found_in_optional[restriction_index]:
                extra_restrictions_sites[
                    (restriction_index,
                     restriction_seqs_found_in_mutated[restriction_index])] = RestrictionSiteType.REMOVE

        # restriction site was added
        for restriction_index in restriction_seqs_found_in_optional:
            if restriction_index not in restriction_seqs_found_in_mutated or restriction_seqs_found_in_optional[
                restriction_index] != restriction_seqs_found_in_mutated[restriction_index]:
                extra_restrictions_sites[
                    (restriction_index,
                     restriction_seqs_found_in_optional[restriction_index])] = RestrictionSiteType.ADD

        return extra_restrictions_sites

    # of all the sequences that create different restriction sites than the 'original' seq (only codon mutations)
    # returns the one with the least mutations
    def find_best_sequence(self, modified_sequences_and_data, restrictions_sites_in_mutated_seq, mutated_sequence,
                           mutation_direction, pam_sites, length_bar: int = 20):
        # first we order to dictionary by number of mutations
        sorted_sequences = sorted(modified_sequences_and_data.items(), key=lambda x: x[1][0])
        valid_sequences_and_data = []
        # first we filter out all sequences that the restriction sites in them are too close or identical to the
        # original sequence (meaning no new restriction sites)
        for item in sorted_sequences:
            rs_data_per_sequence = item[1]
            if not self.do_restriction_sites_dictionaries_match(restrictions_sites_in_mutated_seq[mutated_sequence],
                                                                rs_data_per_sequence):
                sequence_validity = True
                sorted_dic = sorted(rs_data_per_sequence[1].items(), key=lambda x: x[0][0])
                for i in range(len(sorted_dic) - 1):
                    former = sorted_dic[i][0][1]
                    latter = sorted_dic[i + 1][0][0]
                    if latter - former < length_bar:
                        sequence_validity = False
                        break
                if sequence_validity:
                    valid_sequences_and_data.append(item)
        print("we have", str(len(valid_sequences_and_data)), "valid items:", str(valid_sequences_and_data))

        pam_or_crRNA_mutated_sequences = self.find_pam_or_crRNA_changed_sequences(valid_sequences_and_data,
                                                                                  mutation_direction,
                                                                                  pam_sites,
                                                                                  mutated_sequence)
        if len(pam_or_crRNA_mutated_sequences) > 0:
            print("pam site changed!")
            return pam_or_crRNA_mutated_sequences[0][0]
        else:
            return valid_sequences_and_data[0][0]

    @staticmethod
    def find_pam_or_crRNA_changed_sequences(sequences_and_data, mutation_direction, pam_sites, original_sequence):
        valid_sequences_and_data = []
        if mutation_direction == MutationDirection.DOWNSTREAM:
            # need to change PAM site
            for sequence_and_data in sequences_and_data:
                sequence = sequence_and_data[0]
                mutated_indexes = CrisprPlanner.get_mutated_sequence_indexes(sequence, original_sequence)
                for index in mutated_indexes:
                    if index == pam_sites[1] or index == pam_sites[1] - 1:
                        valid_sequences_and_data.append(sequence_and_data)
                        break
        else:
            # need to change crRNA
            crRNA_range = (pam_sites[0] - 20, pam_sites[0] - 1)
            for sequence_and_data in sequences_and_data:
                sequence = sequence_and_data[0]
                mutated_indexes = CrisprPlanner.get_mutated_sequence_indexes(sequence, original_sequence)
                for index in mutated_indexes:
                    if crRNA_range[0] <= index <= crRNA_range[1]:
                        valid_sequences_and_data.append(sequence_and_data)
                        break
        return valid_sequences_and_data

    @staticmethod
    def get_mutated_sequence_indexes(mutated_sequence, original_sequence):
        mutated_indexes = []
        for i in range(len(original_sequence)):
            if mutated_sequence[i] != original_sequence[i]:
                mutated_indexes.append(i)
        return mutated_indexes

    def remove_utr(self):
        seq_without_utr = ''
        for letter in self.sense_strand:
            if 'A' <= letter <= 'Z':
                seq_without_utr += letter
            else:
                continue
        return seq_without_utr


work1 = False
if work1:
    repo_1_sense_strand = "ATGGACTTTCAGAACAGAGCTGGAGGAAAAACGGGAAGCGGAGGAGTGGCTTCGGCCGCCGATGCTGGTGTTGATCGACGGGAACGGCTCCGCCAGTTGGCTCTAGAGACAATTGATCTTCAAAAGGATCCGTATTTCATGCGAAATCACATTGGAACGTACGAATGCAAGCTGTGTCTTACTCTTCACAACAATGAAGGATCTTATTTGGCACATACACAAGGAAAGAAGCATCAAGCGAATCTTGCACGGCGTGCCGCTAAAGAACAATCTGAACAACCATTTCTACCAGCTCCACAGAAAGCTGCAGTTGAAACTAAAAAGTTTGTGAAAATCGGACGTCCTGGATACAAGGTAACAAAAGAACGTGATCCAGGAGCTGGCCAGCAAGCACTTCTCTTCCAAATTGATTATCCGGAGATTGCTGACGGTATTGCGCCACGTCATCGATTTATGTCTGCTTATGAGCAAAAGATTCAGCCTCCAGACAAGAGATGGCAATACCTCTTGTTTGCTGCTGAGCCGTATGAAACGATTGGATTCAAAATTCCATCAAGgtgaggctttacaacattttagcacttttctatctcatagttacgattaaaaaaattgtatataccaagtaattttttccagAGAAGTTGACAAATCTGAAAAATTTTGGACGATGTGGAACAAAGACACGAAGCAATTCTTCTTACAAGTCGCATTCAAATTGGAACGACTCGATGATCAGCCGTACTATTGAtactctatgtttttatctttttgatttcaaaattcaaaacaattttttcgtgtttttcgatgatctaacaataaattattttcctttttttt"
    # sense_strand = "gcattgtaaggagaagccgggtaattaatacgataggcgccgttacaaaccgccaactggtgatcattattctctgaaaATGGAGCCGCGGACAGACGGAGCAGAATGCGGTGTCCAGgtattaattttccccgcctagattttccaatttcatattgttttcagGTATTTTGTCGTATTCGGCCGCTCAATAAGACCGAGGAGAAGAATGCGGACCGTTTCCTGCCCAAATTCCCTTCCGAGGACAGTATATCGCTTGGGgtgagtaatacaaaggggtcatagggaacaattatgtcaacagggacgggaagcacgggggatgcaggtgtgtcaattctctcacatgacacattcatctgtttgaaaagtacacgaaaagtgcaaagttgaatatatatatatatatcgattgatttgttggaatttttcagGGAAAAGTATACGTGTTCGATAAAGTGTTCAAGCCGAACACCACGCAAGAGCAAGTGTACAAAGGAGCCGCTTATCACATCGTACAGGATGTATTATCCGGTTATAATGGAACAGTTTTTGCATATGGACAAACATCTTCCGGAAAAACACATACAATGGAGgtaggaattatgaaaaccttgataattacgtagaatgcgacaaagacaatcaagttgtaatatcaacagtgcaaatctttactgattaatgaaaagaaaagtttgagaactaattttcagcagttatttccgaaatcgaatgcccgaaagatttttgataatttttacgtttaaaatattcggcgctcgatgaaattaacaatataatttaattattttcatattttttacagGGAGTAATCGGTGATAATGGCTTGTCGGGAATCATTCCACGTATCGTTGCTGACATCTTTAACCACATTTATAGTATGGACGAGAATCTTCAATTTCACATCAAAGTGTCCTATTATGAAATTTACAACGAGAAGATTCGAGATTTATTAGACCCCGAGAAGGTCAATTTGTCCATTCATGAAGATAAAAATCGAGTGCCATACGTGAAGGGAGCCACCGAACGGTTTGTTGGAGGACCCGATGAGGTTCTTCAGGCAATCGAAGATGGAAAATCCAACAGAATGGTTGCAGTTACGAgtgagtaaacttaaaattaaacaaattaacatgtgaacgaaatttcagACATGAACGAACATTCTTCTCGATCTCATTCCGTCTTCTTGATTACTGTGAAACAAGAACATCAGACAACAAAGAAACAGCTCACCGGAAAGCTTTATCTTGTTGATTTGGCTGGTTCTGAGAAAGTGAGCAAAACTGGAGCTCAAGGAACAGTTTTAGAAGAAGCCAAAAACATCAACAAGTCACTTACTGCACTCGGAATAGTTATTTCAGCATTGGCTGAAGGAACTgtgagttgtttaaattatgaccttcttaaaacgaatatttatttcagAAATCTCATGTTCCATATCGTGATTCCAAACTGACTCGTATTCTTCAAGAATCTCTAGGAGGAAATTCCCGTACTACAGTTATTATTTGTGCTTCTCCGTCACATTTCAACGAAGCTGAAACTAAATCCACACTTTTGTTCGGAGCACGTGCGAAGACTATCAAGAATGTTGTACAAATCAACGAAGAGCTCACAGCAGAAGAATGGAAACGGCGATATGAGAAAGAAAAAGAGAAGAATACTCGATTGGCCGCCCTTCTCCAGGCAGCGGCTTTGGAACTTTCACGCTGGCGTGCTGGAGAATCAGTGTCTGAGGTTGAATGGGTCAATCTATCAGATTCTGCTCAAATGGCTGTGTCGGAAGTTTCTGGTGGGTCGACTCCACTCATGGAACGTTCGATTGCTCCAGCTCCTCCAATGCTAACTTCTACAACTGGCCCGATCACTGACGAAGAGAAGAAGAAGTACGAAGAGGAACGTGTCAAACTGTATCAGCAACTCGACGAGAAAGATGATGAGATTCAAAAAGTTTCGCAAGAGCTTGAGAAGCTTAGACAACAAGTTCTTCTCCAAGAAGAAGCTTTGGGAACTATGCGTGAAAACGAGGAGCTGATCCGTGAAGAGAACAACCGATTCCAAAAAGAAGCTGAAGACAAGCAGCAAGAAGGAAAGGAAATGATGACAGCTCTGGAAGAGATTGCTGTCAACTTGGATGTTCGACAAGCAGAATGCGAAAAATTGAAGAGAGAGTTGGAAGTTGTTCAAGAAGATAACCAGAGTTTGGAAGATCGAATGAACCAAGCAACATCACTCCTCAATGCTCATCTTGACGAATGTGGTCCAAAAATCCGTCATTTCAAAGAAGGAATCTACAATGTTATTCGTGAATTCAACATTGCTGACATTGCCTCTCAAAATGATCAACTTCCTGATCACGATCTTCTGAACCATGTCAGAATCGGAGTTTCAAAACTCTTCTCAGAATACTCTGCTGCGAAAGAGAGCAGTACAGCTGCCGAGCATGATGCTGAAGCGAAACTTGCAGCTGATGTTGCTCGTGTTGAATCTGGTCAAGACGCGGGTAGAATGAAACAATTGCTGGTGAAGGATCAGGCGGCAAAGGAGATCAAGCCACTAACAGATCGTGTCAATATGGAGCTTACAACGTTGAAGAATTTGAAAAAGGAGTTCATGAGAGTACTTGTTGCTCGATGCCAAGCCAATCAAGACACCGAGGGAGAAGATTCTCTCAGTGGACCAGCTCAAAAGCAACGAATTCAGTTCTTGGAGAACAATTTGGACAAGTTGACGAAGGTTCACAAGCAGgtttgtcgtttttattctcattttgattatcttaaaacttgaattttcagCTTGTTCGCGACAATGCCGATTTGCGCGTTGAACTGCCAAAGATGGAAGCTCGTCTTCGTGGTCGTGAAGATCGCATCAAAATATTAGAAACTGCTCTTCGTGATTCGAAGCAACGTAGTCAAGCAGAACGAAAGAAGTATCAACAAGAAGTTGAACGAATCAAGGAAGCTGTTCGACAACGTAACATGCGACGAATGAATGCTCCACAAATTGTGAAGCCAATCCGTCCAGGACAAGTGTATACGTCTCCGTCAGCAGGAATGTCACAAGGAGCTCCAAATGGCTCAAACGgtgtgtttagtcagacatctacaccttcaacatctcgcaatcagataccatcaaaaatgactatttcacagttgattgcagaaatttaagatttttttaaaaattctttagtgctcatgtaatttttcacaagtaattatactatgaattagaattagagtgagtgtttctttttcttcctaccgtattatcaaatttaacagtcttttgtccgtccatttttcactaatcaaagtttttcagCATAAtgtctcccaacaacaacatcaactcatcgtcttctttgatccaatcaatacactgaagactgacattcaaatgcttctctatctctcttcttttcccggctttgtgatatactttcgatgggcttttctgtttattttaaaatctagtaacttatacaattacgcggcttctggaagtttcaacaaaaatatcttcatttggttggttgtgtctccccatttcgttccttggcttctcgtcttccatgtagaatacaaaacttcaaaagctaaaagtatttaaagcttccctccacccccacccaaattgcctttttccgcctttttgttctaatagtctgtttctatacgattttcctgtttcagttttactaatctgacacgaggttttgtctggttcttccccccgtcacccaccaacactcctatgattgttttttgcatgcgtttgagtgtctttaaagcttgcttgctaaatccccctatcattcttcataagaaatcaacttgtttcgtttctgcacaattcggcccccaaatccccgcacatcccaattg"
    repo_1_aa_sequence = "MDFQNRAGGKTGSGGVASAADAGVDRRERLRQLALETIDLQKDPYFMRNHIGTYECKLCLTLHNNEGSYLAHTQGKKHQANLARRAAKEQSEQPFLPAPQKAAVETKKFVKIGRPGYKVTKERDPGAGQQALLFQIDYPEIADGIAPRHRFMSAYEQKIQPPDKRWQYLLFAAEPYETIGFKIPSREVDKSEKFWTMWNKDTKQFFLQVAFKLERLDDQPYY"
    # amino_acid_sequence = "MEPRTDGAECGVQVFCRIRPLNKTEEKNADRFLPKFPSEDSISLGGKVYVFDKVFKPNTTQEQVYKGAAYHIVQDVLSGYNGTVFAYGQTSSGKTHTMEGVIGDNGLSGIIPRIVADIFNHIYSMDENLQFHIKVSYYEIYNEKIRDLLDPEKVNLSIHEDKNRVPYVKGATERFVGGPDEVLQAIEDGKSNRMVAVTNMNEHSSRSHSVFLITVKQEHQTTKKQLTGKLYLVDLAGSEKVSKTGAQGTVLEEAKNINKSLTALGIVISALAEGTKSHVPYRDSKLTRILQESLGGNSRTTVIICASPSHFNEAETKSTLLFGARAKTIKNVVQINEELTAEEWKRRYEKEKEKNTRLAALLQAAALELSRWRAGESVSEVEWVNLSDSAQMAVSEVSGGSTPLMERSIAPAPPMLTSTTGPITDEEKKKYEEERVKLYQQLDEKDDEIQKVSQELEKLRQQVLLQEEALGTMRENEELIREENNRFQKEAEDKQQEGKEMMTALEEIAVNLDVRQAECEKLKRELEVVQEDNQSLEDRMNQATSLLNAHLDECGPKIRHFKEGIYNVIREFNIADIASQNDQLPDHDLLNHVRIGVSKLFSEYSAAKESSTAAEHDAEAKLAADVARVESGQDAGRMKQLLVKDQAAKEIKPLTDRVNMELTTLKNLKKEFMRVLVARCQANQDTEGEDSLSGPAQKQRIQFLENNLDKLTKVHKQLVRDNADLRVELPKMEARLRGREDRIKILETALRDSKQRSQAERKKYQQEVERIKEAVRQRNMRRMNAPQIVKPIRPGQVYTSPSAGMSQGAPNGSNA"
    cp = CrisprPlanner("repo-1",
                       aa_mutation_site=31,
                       sense_strand=repo_1_sense_strand,
                       amino_acid_sequence=repo_1_aa_sequence)
    cp.plan_my_crispr(from_aa=AminoAcid.ARGININE, to_aa=AminoAcid.GLUTAMINE)
    # cp.plan_my_crispr(aa_mutation_site=26)

work2 = False
if work2:
    # seq = "GCCCCAACAAT"
    # demands = {4: 'C', 5: 'A', 6: 'A'}
    # pam_sites = (6, 8)
    mutants_dic = {}
    CrisprPlanner.modify_seq_to_change_restriction_sites("TCCAACA", {2: "C", 3: "A", 4: "A"},
                                                         mutants=mutants_dic, max_mutations=2, mutations_so_far=0)
    print(mutants_dic)
    print(str(len(mutants_dic)))

work3 = False
if work3:
    mutated_seq = "CCGGACAA"
    CrisprPlanner.find_restriction_sites("TCCGCCAG")

work4 = False
if work4:
    a = "AAA"
    b = AminoAcid.ASPARAGINE
    codon, details = CrisprPlanner.how_to_get_b_from_a(a, b)
    print(codon, str(details))

work5 = True
if work5:
    gene_name = 'cct-1'
    aa_mutation_site = 287
    nt_seq = "gtaATGGCATCAGCTGGAGATTCCATTCTTGCCCTCACCGGTAAAAGAACTACTGGACAAGGCATCAGATCTCAGAATGgtaacaccgaaagctcaatataagtatacattaattaattgcagTCACCGCGGCAGTTGCGATCGCCAATATTGTGAAGTCATCTCTTGGCCCTGTCGGACTTGATAAAATGCTTGTCGATGATGTTGGAGATGTCATTGTCACAAATGACGGAGCCACAATTCTGAAACAACTCGAGGTTGAGCATCCGGCTGGAAAAGTGCTTGTAGAACTTGCACAGCTGCAAGACGAGGAGGTCGGAGATGGAACTACTTCTGTCGTTATTGTGGCGGCTGAGCTCTTGAAGAGAGCCGATGAGCTTGTGAAACAAAAAGTTCATCCGACGACTATTATCAATGGTTACCGTCTCGCGTGCAAGGAAGCCGTCAAGTACATTAGTGAAAACATCTCATTCACTTCCGACTCGATTGGTAGACAATCAGTTGTCAACGCTGCCAAAACTTCCATGAGCAGTAAGATTATCGGACCgtgagtttggtgttgtctatgcttcaagaaaattgatttttcagAGACGCCGATTTCTTCGGAGAGCTGGTTGTTGATGCCGCGGAAGCTGTTCGTGTGGAAAATAACGGGAAAGTCACTTATCCTATCAATGCAGTCAATGTTCTGAAGGCCCACGGAAAGAGCGCTCGCGAATCAGTTTTGGTGAAAGGATATGCACTCAATTGCACAGTTGCCAGTCAGGCCATGCCACTTCGTGTTCAAAATGCCAAGATCGCATGTCTCGATTTCTCTTTGATGAAGGCTAAGATGCACCTCGGTATTTCAGTCGTTGTTGAAGATCCAGCCAAGCTTGAGGCTATTCGCAGAGAgtgagttgaaactattcgtttctttttaagctatggaattttcagAGAATTCGATATTACCAAACGCCGCATTGATAAAATTTTGAAAGCCGGAGCCAACGTTGTTCTTACAACTGGAGGTATCGATGATTTGTGCTTGAAGCAATTTGTCGAATCTGGAGCTATGGCTGTTCGTCGATGCAAGAAATCAGACTTGAAGAGAATTGCCAAAGCTACTGGAGCCACATTGACTGTTTCCTTGGCTACTTTGGAAGGAGATGAAGCTTTCGATGCCTCGCTTCTTGGACATGCCGATGAAATTGTTCAAGAAAGAATTAGTGACGACGAGCTCATTCTCATCAAGGGACCGAAATCTCGTACTGCCAGCAGCATTATCCTCCGTGGAGCGAACGATGTGATGCTCGATGAAATGGAGAGATCGGTTCACGACTCACTCTGTGTTGTTCGTAGAGTTCTGGAAAGCAAGAAACTTGTGGCTGGAGGAGGTGCTGTTGAGACTTCTCTCAGTCTTTTCCTTGAAACTTATGCACAAACCTTGTCTTCTCGCGAGCAGCTTGCTGTTGCTGAATTCGCTTCAGCGCTTCTCATCATTCCGAAGGTTTTGGCAAGCAATGCTGCAAGAGATTCTACTGATTTAGTGACAAAACTCCGCGCGTACCACTCCAAAGCTCAATTGATCCCACAACTTCAACACCTCAAGTGgtaagtgaaaatgttttttttaaagagtaggttattacatgttagcttaatgtaataaaattaaaataatttatttcaaaaaatttcgttttgtgcttagaaaaagcgtctaattcatgttttctgaatttgagtcagtttattcactctttttttagGGCTGGTTTGGATCTCGAAGAAGGCACGATCCGCGATAACAAGGAGGCTGGAATTTTGGAGCCAGCTCTTAGTAAGGTCAAGTCTCTGAAGTTCGCCACTGAGGCAGCCATTACGATATTGCGTATTGATGACCTCATCAAACTTGACAAGCAAGAGCCACTTGGAGGAGATGATTGCCACGCTTAAattttcccgtttaccccgtttatatatccctgttttccgcgtgcttctcacataattccgatctgctgctccttatcccaaattctcatgttcagcttttgttttcttcttttgatgatactttattgaacgaaatgttgtaagttttaatgttttgatttcaaagttgtttgtattcgtttttcattattcaaacaatgaagaagctttgccac"
    check_consistency = True
    CrisprPlanner(gene_name=gene_name, aa_mutation_site=aa_mutation_site, sense_strand=nt_seq). \
        plan_my_crispr(from_aa=AminoAcid.ASPARAGINE,
                       to_aa=AminoAcid.SERINE,
                       check_consistency=check_consistency)
work6 = False
if work6:
    print(CrisprPlanner.how_to_get_b_from_a("ACG", AminoAcid.ALANINE))
