from Code.CRISPR.Enum.AminoAcid import AminoAcid
from Code.CRISPR.Enum.MutationDirection import MutationDirection
import random
import re

from Code.CRISPR.Enum.RestrictionSiteType import RestrictionSiteType


class CrisprPlanner:

    possibilities = {'A': 'C', 'C': 'T', 'T': 'G', 'G': 'A'}

    codon_dic = {'A': {'GCT', 'GCC', 'GCA', 'GCG'}, 'C': {'TGT', 'TGC'}, 'D': {'GAT', 'GAC'}, 'E': {'GAA', 'GAG'},
                 'F': {'TTT', 'TTC'}, 'G': {'GGT', 'GGC', 'GGA', 'GGG'}, 'H': {'CAT', 'CAC'},
                 'I': {'ATT', 'ATC', 'ATA'}, 'K': {'AAA', 'AAG'}, 'L': {'TTA', 'TTG', 'CTT', 'CTC', 'CTA', 'CTG'},
                 'M': {'ATG'}, 'N': {'AAT', 'AAC'}, 'P': {'CCT', 'CCC', 'CCA', 'CCG'}, 'Q': {'CAA', 'CAG'},
                 'R': {'CGT', 'CGC', 'CGA', 'CGG', 'AGA', 'AGG'}, 'S': {'TCT', 'TCC', 'TCA', 'TCG', 'AGT', 'AGC'},
                 'T': {'ACT', 'ACC', 'ACA', 'ACG'}, 'V': {'GTT', 'GTC', 'GTA', 'GTG'}, 'W': {'TGG'},
                 'Y': {'TAT', 'TAC'}, 'STOP': {'TAA', 'TAG', 'TGA'}}

    codon_usage = {'UUU': 23.3, 'UCU': 16.7, 'UAU': 17.5, 'UGU': 11.2, 'UUC': 23.9, 'UCC': 10.6, 'UAC': 13.7, 'UGC':9.1,
                   'UUA': 9.8, 'UCA': 20.6, 'UAA': 1.6, 'UGA': 1.4, 'UUG': 20.0, 'UCG': 12.2, 'UAG': 0.6, 'UGG': 11.1,
                   'CUU': 21.2, 'CCU': 8.8, 'CAU': 14.1, 'CGU': 11.2, 'CUC': 14.8, 'CCC': 4.4, 'CAC': 9.2, 'CGC': 5.1,
                   'CUA': 7.9, 'CCA': 26.1, 'CAA': 27.4, 'CGA': 12.1, 'CUG': 12.1, 'CCG': 9.7, 'CAG': 14.4, 'CGG': 4.7,
                   'AUU': 32.2, 'ACU': 18.9, 'AAU': 30.2, 'AGU': 12.1, 'AUC': 18.9, 'ACC': 10.4, 'AAC': 18.3, 'AGC': 8.4,
                   'AUA': 9.5, 'ACA': 20.0, 'AAA': 37.5, 'AGA': 15.4, 'AUG': 26.1, 'ACG': 8.9, 'AAG': 25.8, 'AGG': 4.0,
                   'GUU': 24.1, 'GCU': 22.4, 'GAU': 35.8, 'GGU': 10.9, 'GUC': 13.6, 'GCC': 12.6, 'GAC': 17.1, 'GGC': 6.7,
                   'GUA': 9.8, 'GCA': 19.8, 'GAA': 40.8, 'GGA': 31.7, 'GUG': 14.3, 'GCG': 8.2, 'GAG': 24.5, 'GGG': 4.4}

    restriction_sites = ['ACCGGT', 'GTGCAC', 'ATTAAT', 'GGATCC', 'AGATCT', 'ATCGAT', 'GAATTC', 'GATATC', 'AGCGCT',
                         'GGCGCT', 'AGCGCC', 'GGCGCC', 'AAGCTT', 'GGTGA', 'GGTACC', 'TGGCCA', 'CCATGG', 'CATATG',
                         'GCTAGC', 'GCGGCCGC', 'CTGCAG', 'CAGCTG', 'GAGCTC', 'CCTGCAGG', 'TACGTA', 'ACTAGT',
                         'TCTAGA', 'CTCGAG', 'CCCGGG', 'AATT', 'GTAC', 'TCGA', 'GATC', 'CCGG']

    def __init__(self, sense_strand, aa_mutation_site, amino_acid_sequence: str = ""):
        self.sense_strand = sense_strand
        self.anti_sense_strand = CrisprPlanner.get_anti_sense_strand(sense_strand)
        self.amino_acid_sequence = amino_acid_sequence
        self.amino_acid_mutation_site = aa_mutation_site

    def get_relevant_strand(self, direction):
        if direction > 0:
            return self.sense_strand
        else:
            return self.anti_sense_strand

    def find_recognition_sequence(self, from_aa: AminoAcid, to_aa: AminoAcid, window_size: int = 30,
                                  PAM_size: int = 3):
        sense_mutation_site = self.find_site_in_nt_seq(amino_acid_site=self.amino_acid_mutation_site,
                                                       check_sequence_consistency=True)
        print("mutation site in sense strand is: " + str(sense_mutation_site))
        anti_sense_mutation_site = self.get_mutation_site_for_anti_sense(sense_mutation_site)
        print("mutation site in anti-sense strand: " + str(anti_sense_mutation_site))

        # get optional sequences for crRNA
        sense_strand_sequences = CrisprPlanner.get_list_of_potential_sequences(self.sense_strand,
                                                                               sense_mutation_site,
                                                                               window_size,
                                                                               PAM_size)
        anti_sense_strand_sequences = CrisprPlanner.\
            get_list_of_potential_sequences(self.anti_sense_strand,
                                            anti_sense_mutation_site,
                                            window_size,
                                            PAM_size)
        print("Sense crRNAs: ")
        for sequence in sense_strand_sequences:
            print(sequence)
            pam_site_start = sequence[1][1]
            pam_site_end = sequence[1][1]+3
            print("PAM sequence: " + self.sense_strand[pam_site_start:pam_site_end])
        print("Anti Sense crRNAs: ")
        for sequence in anti_sense_strand_sequences:
            print(sequence)
            pam_site_start = sequence[1][1]
            pam_site_end = sequence[1][1]+3
            print("PAM sequence: " + self.anti_sense_strand[pam_site_start:pam_site_end])

        chosen_crrna, strand_direction = CrisprPlanner.choose_best_crrna(sense_strand_sequences,
                                                                         anti_sense_strand_sequences)
        # now we have our cr_rna
        print("chosen crRNA: " + str(chosen_crrna))
        strand_str = "anti-" if strand_direction < 0 else ""
        print("The relevant strand is " + strand_str + "sense")

        pam_site_start = chosen_crrna[1][1]
        pam_site_end = chosen_crrna[1][1]+2
        pam_sites = (pam_site_start, pam_site_end)

        ssODN_strand_direction, mutation_direction = CrisprPlanner.\
            choose_ssODN_strand(sense_mutation_site if strand_direction > 0 else anti_sense_mutation_site,
                                strand_direction,
                                pam_site_start)
        print("ssODN direction is:", str(ssODN_strand_direction), "and mutation direction is:", str(mutation_direction))
        if ssODN_strand_direction != strand_direction:
            print("The ssODN is on the opposite strand!")
            # ssODN is not on the strand from which we got the crRNA, thus we need to find its pam sites again
            pam_sites = (self.find_index_in_parallel_strand(pam_site_end),
                         self.find_index_in_parallel_strand(pam_site_start))
            print("pam sites on the ssODN strand:", pam_sites)

        # to be mutated
        mutated_strand = self.sense_strand if ssODN_strand_direction > 0 else self.anti_sense_strand
        ssODN_mutation_site = sense_mutation_site if ssODN_strand_direction > 0 else anti_sense_mutation_site

        # getting the zone where all mutations will be located: after to before DSB
        mutations_zone = self.get_mutations_zone(mutation_direction, pam_sites)
        # sanity check
        print("mutation is starting from", ssODN_mutation_site, "and mutations zone is", str(mutations_zone))

        # 1. mutation to change codon
        mutated_strand, codon_mutated_sites = self.apply_codon_mutation(mutated_strand, ssODN_mutation_site,
                                                                        self.get_demands(from_aa, to_aa,
                                                                                         sense_mutation_site))

        # making sure that the strand is good so far
        print("mutated strand after adding codon mutation: ", mutated_strand)
        print("sites changed:", codon_mutated_sites)

        # 2. mutations to add/remove restriction sites
        print("Add or Remove restriction sites:")
        self.add_remove_restriction_sites(mutated_strand, mutations_zone, ssODN_strand_direction,
                                          codon_mutated_sites, mutation_direction, pam_sites)

        # 2. mutations to change nt to prevent re-attachments - in PAM or crRNA sequence
        # mutated_strand, mutated_sites = self.apply_mutation(mutated_strand, mutation_direction, mutations_zone,
        #                                                     pam_sites, codon_mutated_sites)




        #
        # pam_site_mutated = self.check_if_pam_site_mutated(mutated_sites, pam_sites)
        # if not pam_site_mutated:
        #     mutated_strand = self.mutate_pam_site(mutated_strand, )
        # print("pam sites inside: " + str(pam_sites) + ", mutation site: " + str(ssODN_mutation_site-1))
        # print("pam sites for opposite strand: " + str(pam_site_start), str(pam_site_end))



    # this function receives (1) an amino acid sequence site and (2) the nt sequence and returns the nt sequence site
    # that correlates to the amino acid sequence site
    # it doesn't count for 0, so if we're talking about the first amino acid
    def find_site_in_nt_seq(self, amino_acid_site, check_sequence_consistency: bool = False):
        i = 0
        index = 0
        while i < len(self.sense_strand):
            # region is intron
            if self.sense_strand[i].islower():
                i += 1
            else:
                index += 1
                if index == amino_acid_site:
                    return i
                else:
                    if check_sequence_consistency:
                        CrisprPlanner.check_sequence_consistency(self.sense_strand[i:i + 3],
                                                                 self.amino_acid_sequence[index - 1])
                    i += 3

    # receives (1) a codon string and (2) the relevant amino and checks if the codon translates to this amino acid
    @staticmethod
    def check_sequence_consistency(input_codon, amino_acid):
        codon_table = {'GCT': 'A', 'TGT': 'C', 'GAT': 'D', 'GAA': 'E', 'TTT': 'F', 'GGT': 'G', 'CAT': 'H',
                       'ATT': 'I', 'AAA': 'K', 'TTA': 'L', 'ATG': 'M', 'AAT': 'N', 'CCT': 'P', 'CAA': 'Q',
                       'CGT': 'R', 'TCT': 'S', 'ACT': 'T', 'GTT': 'V', 'TGG': 'W', 'TAT': 'Y', 'TTC': 'F',
                       'TTG': 'L', 'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L', 'ATC': 'I', 'ATA': 'I',
                       'GTC': 'V', 'GTA': 'V', 'GTG': 'V', 'TCC': 'S', 'TCA': 'S', 'TCG': 'S', 'CCC': 'P',
                       'CCA': 'P', 'CCG': 'P', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T', 'GCC': 'A', 'GCA': 'A',
                       'GCG': 'A', 'TAC': 'Y', 'TAA': 'STOP', 'TAG': 'STOP', 'CAC': 'H', 'CAG': 'Q', 'AAC': 'N',
                       'AAG': 'K', 'GAC': 'D', 'GAG': 'E', 'TGC': 'C', 'TGA': 'STOP', 'CGC': 'R', 'CGA': 'R',
                       'CGG': 'R', 'AGT': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R', 'GGC': 'G', 'GGA': 'G',
                       'GGG': 'G'}
        if codon_table[input_codon] != amino_acid:
            print("Instead of " + codon_table[input_codon], ", the amino acid in the sequence is " + amino_acid)

    # receives a (1) strand of nt, (2) the mutation site, (3) the window size around the mutation site where DSB point
    # can be located and (4) size of PAM sequence, checks in the strand for 20 bp sequences around the mutation size
    # that end in PAM sequence ('NGG') and returns a list of those sequences, as a tuple of the sequences and its start
    # and end indexes.
    @staticmethod
    def get_list_of_potential_sequences(strand, mutation_site, window_size, PAM_size, cr_rna_size: int = 20):
        potential_cr_rnas = []
        start_point = max(0, mutation_site - window_size + PAM_size)
        end_point = min(mutation_site + window_size + PAM_size, len(strand) - 1)
        print("start point: " + str(start_point) + ", end point: " + str(end_point))
        for i in range(start_point, end_point):
            if strand[i + 1:i + 3] == "GG":
                try:
                    potential_cr_rna = strand[i - cr_rna_size:i]
                    potential_cr_rnas.append((potential_cr_rna, (i - cr_rna_size, i)))
                except:
                    print("Not enough space for a whole crRNA, i = " + str(i))
                    continue
        return potential_cr_rnas

    # receives (1) the mutation position in the sense strand, and returns the position of this mutation in the
    # anti-sense
    def get_mutation_site_for_anti_sense(self, sense_mutation_site):
        return len(self.anti_sense_strand) - sense_mutation_site - 3

    # receives (1) the sense strand and returns its complementary, from 3' to 5'
    @staticmethod
    def get_anti_sense_strand(given_sense_strand):
        anti_sense_strand = ''
        pair_nucleotides = {'A': 'T', 'C': 'G', 'G': 'C', 'T': 'A', 'a': 't', 'c': 'g', 'g': 'c', 't': 'a'}
        for letter in given_sense_strand:
            anti_sense_strand += pair_nucleotides[letter]
        return anti_sense_strand[::-1]

    # this function gets a nucleotide sequence and adds to a dictionary all restriction sites in the sequence
    @staticmethod
    def find_restriction_sites(nt_seq, number_of_mutations, mutants, methylated: bool = False):
        restriction_sites_in_seq = {}
        for restriction_site in CrisprPlanner.restriction_sites:
            indexes = [m.start() for m in re.finditer('(?=' + restriction_site + ')', nt_seq)]
            for index in indexes:
                if restriction_site == "GGTGA":
                    if index + 8 >= len(nt_seq):
                        continue
                elif restriction_site == "GATC":
                    if not methylated:
                        continue
                restriction_sites_in_seq[(index, index+len(restriction_site))] = restriction_site
        # only if there are some restriction sites
        if restriction_sites_in_seq:
            mutants[nt_seq] = (number_of_mutations, restriction_sites_in_seq)

    # receives a (1) sequence and (2) list containing indexes of the start and end of the PAM site in the sequence,
    # for each index in the PAM sites it changes the amino acid in that index to the other 3 possible, and each
    # mutated PAM site sequence is sent to find restriction sites in
    @staticmethod
    def change_pam_site(seq, pam_sites):
        for nt_index in range(pam_sites[0], pam_sites[1]+1):
            current_seq = seq
            # three iterations
            for i in range(3):
                current_seq = CrisprPlanner.change_char_in_string(current_seq, nt_index,
                                                                  CrisprPlanner.possibilities[current_seq[nt_index]])
                CrisprPlanner.find_restriction_sites(current_seq, 2)

    # receives (1) a sequence, (2) a dictionary of indexes that need to be occupied by a certain nucleotides,
    # (3) a dictionary of indexes that can not be occupied with certain nucleotides, (4) a tuple that contains the start
    # and end PAM sites, (5) the number of max mutation in the sequence, (6) a mutants dictionary to save all the
    # mutants and (7) the number of mutants so far, goes through all nucleotide options each index have and for each
    # combination with one mutation finds if there is a new restriction site. returns the mutants dictionary that
    # contains the mutant sequence as key and the number of mutation in the seq and a dictionary of al restriction
    # sequences and their sites in the sequence as values.
    # It's a recursive function
    @staticmethod
    def modify_seq_to_change_restriction_sites(original_seq, demands_to_be, mutants=dict(), max_mutations: int = 2,
                                               mutations_so_far: int = 0):
        if not mutations_so_far:
            # only once at the beginning
            CrisprPlanner.find_restriction_sites(original_seq, mutations_so_far, mutants)
        if max_mutations <= mutations_so_far:
            return
        for index in range(len(original_seq)):
            if index in demands_to_be:
                continue
            else:
                current_seq = original_seq
                for iteration in range(3):
                    current_seq = CrisprPlanner.change_char_in_string(current_seq, index,
                                                                      CrisprPlanner.possibilities[current_seq[index]])
                    CrisprPlanner.find_restriction_sites(current_seq, mutations_so_far + 1, mutants)
                    # recursion step
                    new_demands = demands_to_be.copy()
                    new_demands.update({index: current_seq[index]})
                    CrisprPlanner.modify_seq_to_change_restriction_sites(current_seq,
                                                                         new_demands,
                                                                         mutants,
                                                                         max_mutations,
                                                                         mutations_so_far + 1)


    @staticmethod
    def change_char_in_string(seq, position, new_char):
        lst = list(seq)
        lst[position] = new_char
        return "".join(lst)

    @staticmethod
    def choose_best_crrna(sense_options: list, anti_sense_options: list):
        num = random.uniform(0, 1)
        if num > 0.5:
            return random.choice(sense_options), 1
        else:
            return random.choice(anti_sense_options), -1

    @staticmethod
    def choose_ssODN_strand(mutation_site, strand_direction, pam_site_start):
        DSB = pam_site_start - 3
        # default assignment
        mutation_direction = MutationDirection.UPSTREAM
        print("mutation site: " + str(mutation_site) +", pam start: " + str(pam_site_start) + ", DSB: " + str(DSB))
        if mutation_site > DSB:
            mutation_direction = MutationDirection.DOWNSTREAM
        elif mutation_site < DSB:
            mutation_direction = MutationDirection.UPSTREAM
        if mutation_direction == MutationDirection.DOWNSTREAM:
            return -1 * strand_direction, mutation_direction
        else:
            return strand_direction, mutation_direction

    def find_index_in_parallel_strand(self, index):
        return len(self.sense_strand) - index - 1

    # this function will return the minimal nucleotides you need to change (and the range of options for change) in
    # order to get from amino acic a to amino acid b
    @staticmethod
    def how_to_get_b_from_a(a_codon, b: AminoAcid):
        b_codons = CrisprPlanner.codon_dic[b.value]
        min_distance = 4
        options = {}
        for b_codon in b_codons:
            distance, demands = CrisprPlanner.codon_distance(a_codon, b_codon)
            if distance < min_distance:
                options = {}
                min_distance = distance
                options[b_codon] = (distance, demands, CrisprPlanner.codon_usage[CrisprPlanner.change_t_to_u(b_codon)])
            elif distance == min_distance:
                options[b_codon] = (distance, demands, CrisprPlanner.codon_usage[CrisprPlanner.change_t_to_u(b_codon)])
        codon, details = CrisprPlanner.get_codon_with_higher_usage(options)
        return codon, details

    @staticmethod
    def codon_distance(a, b):
        distance = 0
        demands = {}
        for i in range(3):
            if a[i] != b[i]:
                distance += 1
                demands[i] = b[i]
        return distance, demands

    @staticmethod
    def change_t_to_u(codon):
        new_codon = ""
        for nt in codon:
            if nt == 'T':
                new_codon += 'U'
            else:
                new_codon += nt
        return new_codon

    # gets a dictionary of options, such that the keys are tuples of the original codon (doesn't change) and new, and
    # the values are 3-tuples which consists of the number of mutations, the instructions and the usage percentage, and
    # returns the key tuple with the highest codon usage
    @staticmethod
    def get_codon_with_higher_usage(codon_options):
        max_codon = ""
        max_usage = 0
        for codon in codon_options.keys():
            value = codon_options[codon]
            usage = value[2]
            if usage > max_usage:
                max_usage = usage
                max_codon = codon
        return max_codon, codon_options[max_codon]

    def get_demands(self, a: AminoAcid, b: AminoAcid, mutation_site):
        sense_codon = self.sense_strand[mutation_site:mutation_site+3]
        codon_options = self.codon_dic[a.value]
        if sense_codon not in codon_options:
            print(f'Codon in mutation site {mutation_site}: {sense_codon} does not translate into {a}')
            exit()
        b_codon, values = CrisprPlanner.how_to_get_b_from_a(sense_codon, b)
        demands = values[1]
        print("change", sense_codon, "to", b_codon, "with demands:", str(demands))

        return demands

    # receives (1) the strand to be mutated, (2) the mutation site in the strand (internal indexing), and (3) the
    # demands to make the change with indexes in respect to the codon, not the strand (so, 0, 1, 2...) and returns the
    # mutated strand
    @staticmethod
    def apply_codon_mutation(strand, mutation_site, demands):
        mutated_sites = []
        for index in demands.keys():
            nt = demands[index]
            position = mutation_site + int(index)
            mutated_sites.append(position)
            strand = CrisprPlanner.change_char_in_string(strand, position, nt)
        return strand, mutated_sites

    @staticmethod
    def check_if_pam_site_mutated(mutated_sites: list, pam_sites: tuple):
        pam_site_mutated = False
        for mutated_site in mutated_sites:
            if pam_sites[0] <= mutated_site <= pam_sites[1]:
                pam_site_mutated = True
                break

        if pam_site_mutated:
            print("pam site mutated")
        else:
            print("pam site not mutated")
        return pam_site_mutated

    # receives (1) the mutation direction (UPSTREAM or DOWNSTREAM) and (2) the pam sites and according to the scheme
    # that shows that for UPSRTREAM mutations, the homology arm that can undergo changes is from the DSB and for
    # DOWNSTREAM mutations, the homology arm that can undergo changes is up until the DSB, returns the right zone of
    # 35 nt. The range is open
    @staticmethod
    def get_mutations_zone(mutation_direction, pam_sites):

        if mutation_direction == MutationDirection.UPSTREAM:
            # untouched homology arm is until DSB
            DSB = pam_sites[0] - 3
        else:
            # untouched homology arm is after DSB
            DSB = pam_sites[1] + 4
        return DSB-36, DSB

    # TBD - change the name of the mutation
    # receives (1) the strand to be mutated, (2) the direction of the mutation to understand whether to mutate the PAM
    # site or the crRNA sequence, (3) the zone in which mutations can be located, (4) the pam sites, (5) the indexes
    # in which mutations have already been located and thus can't be changed, and (6-optional) the number of mutations
    # to insert and returns the mutated strand and the indexes of the mutations
    @staticmethod
    def apply_mutation(mutated_strand, mutation_direction, mutations_zone, pam_sites, codon_mutated_sites,
                       number_of_mutations: int = 2):
        if mutation_direction == MutationDirection.UPSTREAM:
            # change crRNA
            cr_rna_sites_without_dsb = (pam_sites[0]-1-20, pam_sites[0]-1-3)
            print("crRNA sites without DSB:", cr_rna_sites_without_dsb)
            i = 0
            indexes = []
            while i < number_of_mutations:
                index = random.randrange(cr_rna_sites_without_dsb[0], cr_rna_sites_without_dsb[1])
                # make sure that the chosen place will create a silent mutant, third place in the codon
                if index % 3 == 2 and index not in indexes and index not in codon_mutated_sites:
                    if CrisprPlanner.is_within_mutation_zone(mutations_zone, index):
                        indexes.append(index)
                        i += 1
            # now we have indexes to mutate
            #todo
        # change PAM sites
        else:
            mutated_strand = mutated_strand
            # CrisprPlanner.check_if_pam_site_mutated()
            #todo
        return mutated_strand, {}

    @staticmethod
    def is_within_mutation_zone(mutation_zone, place):
        if mutation_zone[0] < place < mutation_zone[1]:
            return True
        else:
            return False

    def add_remove_restriction_sites(self, mutated_strand, mutations_zone, ssODN_direction, codon_mutated_sites,
                                     mutation_direction, pam_sites):
        # first check if the mutated strand so far (with codon mutations) has different number of restriction sites
        # than the original one
        restrictions_sites_in_original_seq = {}
        if ssODN_direction > 0:
            original_sequence = self.sense_strand[mutations_zone[0]+1:mutations_zone[1]]
        else:
            original_sequence = self.anti_sense_strand[mutations_zone[0]+1:mutations_zone[1]]
        self.find_restriction_sites(original_sequence, 0, restrictions_sites_in_original_seq)
        print("restrictions sites in original seq:", restrictions_sites_in_original_seq)

        restrictions_sites_in_mutated_seq = {}
        mutated_sequence = mutated_strand[mutations_zone[0]+1:mutations_zone[1]]
        self.find_restriction_sites(mutated_sequence, len(codon_mutated_sites), restrictions_sites_in_mutated_seq)
        print("restrictions sites in mutated seq:", restrictions_sites_in_mutated_seq)

        if not self.do_restriction_sites_dictionaries_match(restrictions_sites_in_original_seq[original_sequence],
                                                            restrictions_sites_in_mutated_seq[mutated_sequence]):
            print("dictionaries don't match!")
            # the different restriction sites
            rest_sites = self.find_extra_restriction_sites(restrictions_sites_in_original_seq[original_sequence],
                                                           restrictions_sites_in_mutated_seq[mutated_sequence])
        else:
            # dictionaries match
            print("let's modify some sites!")
            modified_sequences = {}
            self.modify_seq_to_change_restriction_sites(mutated_sequence,
                                                        self.create_demands(mutated_strand, codon_mutated_sites),
                                                        modified_sequences)
            print(str(len(modified_sequences)), "have been found:", modified_sequences)

            # now we get the sequence with the chosen new restriction sites
            chosen_seq = self.find_best_sequence(modified_sequences,
                                                 restrictions_sites_in_mutated_seq,
                                                 mutated_sequence,
                                                 mutation_direction,
                                                 pam_sites)

            # find the restriction sites that both sequences don't share
            rest_sites = self.find_extra_restriction_sites(restrictions_sites_in_mutated_seq[mutated_sequence],
                                                           modified_sequences[chosen_seq])
        print("restriction sites changed:", str(rest_sites))


    # gets two dictionaries' values of the format of: (0, {(3, 9): 'TCTAGA'}) and checks if both
    # dictionaries have the same restriction sites
    @staticmethod
    def do_restriction_sites_dictionaries_match(d1_values, d2_values):
        d1_restriction_sites = d1_values[1]
        d2_restriction_sites = d2_values[1]
        if len(d1_restriction_sites) != len(d2_restriction_sites):
            return False
        else:
            for restriction_index in d1_restriction_sites:
                if restriction_index not in d2_restriction_sites:
                    return False
                elif restriction_index in d2_restriction_sites:
                    if d1_restriction_sites[restriction_index] != d2_restriction_sites[restriction_index]:
                        return False
        return True
    # receives (1) the mutated strand and (2) the indexes in which changes have been made and returns a dictionary of
    # the indexes as keys and char in that index in the mutated strand as values
    @staticmethod
    def create_demands(mutated_strand, codon_mutated_sites):
        demands = {}
        for index in codon_mutated_sites:
            demands[index] = mutated_strand[index]
        return demands

    # receives the original sequence (with only codon mutations) and the optional sequence with more mutations that has
    # more\less restrictions sites than the original, and returns the added restriction site and indexes, and whether
    # the change is added restriction site or removed. format: (2, {'TCGA': (19, 23), 'CCGG': (0, 4)})
    @staticmethod
    def find_extra_restriction_sites(mutated_seq_restriction_sites, optioal_seq_restriction_sites):
        extra_restrictions_sites = {}
        mutations_in_mutated, restriction_seqs_found_in_mutated = mutated_seq_restriction_sites
        mutations_in_optional, restriction_seqs_found_in_optional = optioal_seq_restriction_sites

        # restriction site was removed
        for restriction_index in restriction_seqs_found_in_mutated:
            if restriction_index not in restriction_seqs_found_in_optional or restriction_seqs_found_in_mutated[restriction_index] != restriction_seqs_found_in_optional[restriction_index]:
                extra_restrictions_sites[
                    (restriction_index,
                     restriction_seqs_found_in_mutated[restriction_index])] = RestrictionSiteType.REMOVE

        # restriction site was added
        for restriction_index in restriction_seqs_found_in_optional:
            if restriction_index not in restriction_seqs_found_in_mutated or restriction_seqs_found_in_optional[restriction_index] != restriction_seqs_found_in_mutated[restriction_index]:
                extra_restrictions_sites[
                    (restriction_index,
                     restriction_seqs_found_in_optional[restriction_index])] = RestrictionSiteType.ADD

        return extra_restrictions_sites

    # of all the sequences that create different restriction sites than the 'original' seq (only codon mutations)
    # returns the one with the least mutations
    def find_best_sequence(self, modified_sequences_and_data, restrictions_sites_in_mutated_seq, mutated_sequence,
                           mutation_direction, pam_sites, length_bar: int = 20):
        # first we order to dictionary by number of mutations
        sorted_sequences = sorted(modified_sequences_and_data.items(), key=lambda x: x[1][0])
        valid_sequences_and_data = []
        # first we filter out all sequences that the restriction sites in them are too close or identical to the
        # original sequence (meaning no new restriction sites)
        for item in sorted_sequences:
            rs_data_per_sequence = item[1]
            if not self.do_restriction_sites_dictionaries_match(restrictions_sites_in_mutated_seq[mutated_sequence],
                                                                rs_data_per_sequence):
                sequence_validity = True
                sorted_dic = sorted(rs_data_per_sequence[1].items(), key=lambda x: x[0][0])
                for i in range(len(sorted_dic)-1):
                    former = sorted_dic[i][0][1]
                    latter = sorted_dic[i+1][0][0]
                    if latter-former < length_bar:
                        sequence_validity = False
                        break
                if sequence_validity:
                    valid_sequences_and_data.append(item)
        print("we have", str(len(valid_sequences_and_data)), "valid items:", str(valid_sequences_and_data))

        pam_or_crRNA_mutated_sequences = self.find_pam_or_crRNA_changed_sequences(valid_sequences_and_data,
                                                                                  mutation_direction,
                                                                                  pam_sites,
                                                                                  mutated_sequence)
        if len(pam_or_crRNA_mutated_sequences) > 0:
            print("pam site changed!")
            return pam_or_crRNA_mutated_sequences[0][0]
        else:
            return valid_sequences_and_data[0][0]

    @staticmethod
    def find_pam_or_crRNA_changed_sequences(sequences_and_data, mutation_direction, pam_sites, original_sequence):
        valid_sequences_and_data = []
        if mutation_direction == MutationDirection.DOWNSTREAM:
            # need to change PAM site
            for sequence_and_data in sequences_and_data:
                sequence = sequence_and_data[0]
                mutated_indexes = CrisprPlanner.get_mutated_sequence_indexes(sequence, original_sequence)
                for index in mutated_indexes:
                    if index == pam_sites[1] or index == pam_sites[1]-1:
                        valid_sequences_and_data.append(sequence_and_data)
                        break
        else:
            # need to change crRNA
            crRNA_range = (pam_sites[0]-20, pam_sites[0]-1)
            for sequence_and_data in sequences_and_data:
                sequence = sequence_and_data[0]
                mutated_indexes = CrisprPlanner.get_mutated_sequence_indexes(sequence, original_sequence)
                for index in mutated_indexes:
                    if crRNA_range[0] <= index <= crRNA_range[1]:
                        valid_sequences_and_data.append(sequence_and_data)
                        break
        return valid_sequences_and_data

    @staticmethod
    def get_mutated_sequence_indexes(mutated_sequence, original_sequence):
        mutated_indexes = []
        for i in range(len(original_sequence)):
            if mutated_sequence[i] != original_sequence[i]:
                mutated_indexes.append(i)
        return mutated_indexes


work1 = True
if work1:
    repo_1_sense_strand = "ATGGACTTTCAGAACAGAGCTGGAGGAAAAACGGGAAGCGGAGGAGTGGCTTCGGCCGCCGATGCTGGTGTTGATCGACGGGAACGGCTCCGCCAGTTGGCTCTAGAGACAATTGATCTTCAAAAGGATCCGTATTTCATGCGAAATCACATTGGAACGTACGAATGCAAGCTGTGTCTTACTCTTCACAACAATGAAGGATCTTATTTGGCACATACACAAGGAAAGAAGCATCAAGCGAATCTTGCACGGCGTGCCGCTAAAGAACAATCTGAACAACCATTTCTACCAGCTCCACAGAAAGCTGCAGTTGAAACTAAAAAGTTTGTGAAAATCGGACGTCCTGGATACAAGGTAACAAAAGAACGTGATCCAGGAGCTGGCCAGCAAGCACTTCTCTTCCAAATTGATTATCCGGAGATTGCTGACGGTATTGCGCCACGTCATCGATTTATGTCTGCTTATGAGCAAAAGATTCAGCCTCCAGACAAGAGATGGCAATACCTCTTGTTTGCTGCTGAGCCGTATGAAACGATTGGATTCAAAATTCCATCAAGgtgaggctttacaacattttagcacttttctatctcatagttacgattaaaaaaattgtatataccaagtaattttttccagAGAAGTTGACAAATCTGAAAAATTTTGGACGATGTGGAACAAAGACACGAAGCAATTCTTCTTACAAGTCGCATTCAAATTGGAACGACTCGATGATCAGCCGTACTATTGAtactctatgtttttatctttttgatttcaaaattcaaaacaattttttcgtgtttttcgatgatctaacaataaattattttcctttttttt"
    # sense_strand = "gcattgtaaggagaagccgggtaattaatacgataggcgccgttacaaaccgccaactggtgatcattattctctgaaaATGGAGCCGCGGACAGACGGAGCAGAATGCGGTGTCCAGgtattaattttccccgcctagattttccaatttcatattgttttcagGTATTTTGTCGTATTCGGCCGCTCAATAAGACCGAGGAGAAGAATGCGGACCGTTTCCTGCCCAAATTCCCTTCCGAGGACAGTATATCGCTTGGGgtgagtaatacaaaggggtcatagggaacaattatgtcaacagggacgggaagcacgggggatgcaggtgtgtcaattctctcacatgacacattcatctgtttgaaaagtacacgaaaagtgcaaagttgaatatatatatatatatcgattgatttgttggaatttttcagGGAAAAGTATACGTGTTCGATAAAGTGTTCAAGCCGAACACCACGCAAGAGCAAGTGTACAAAGGAGCCGCTTATCACATCGTACAGGATGTATTATCCGGTTATAATGGAACAGTTTTTGCATATGGACAAACATCTTCCGGAAAAACACATACAATGGAGgtaggaattatgaaaaccttgataattacgtagaatgcgacaaagacaatcaagttgtaatatcaacagtgcaaatctttactgattaatgaaaagaaaagtttgagaactaattttcagcagttatttccgaaatcgaatgcccgaaagatttttgataatttttacgtttaaaatattcggcgctcgatgaaattaacaatataatttaattattttcatattttttacagGGAGTAATCGGTGATAATGGCTTGTCGGGAATCATTCCACGTATCGTTGCTGACATCTTTAACCACATTTATAGTATGGACGAGAATCTTCAATTTCACATCAAAGTGTCCTATTATGAAATTTACAACGAGAAGATTCGAGATTTATTAGACCCCGAGAAGGTCAATTTGTCCATTCATGAAGATAAAAATCGAGTGCCATACGTGAAGGGAGCCACCGAACGGTTTGTTGGAGGACCCGATGAGGTTCTTCAGGCAATCGAAGATGGAAAATCCAACAGAATGGTTGCAGTTACGAgtgagtaaacttaaaattaaacaaattaacatgtgaacgaaatttcagACATGAACGAACATTCTTCTCGATCTCATTCCGTCTTCTTGATTACTGTGAAACAAGAACATCAGACAACAAAGAAACAGCTCACCGGAAAGCTTTATCTTGTTGATTTGGCTGGTTCTGAGAAAGTGAGCAAAACTGGAGCTCAAGGAACAGTTTTAGAAGAAGCCAAAAACATCAACAAGTCACTTACTGCACTCGGAATAGTTATTTCAGCATTGGCTGAAGGAACTgtgagttgtttaaattatgaccttcttaaaacgaatatttatttcagAAATCTCATGTTCCATATCGTGATTCCAAACTGACTCGTATTCTTCAAGAATCTCTAGGAGGAAATTCCCGTACTACAGTTATTATTTGTGCTTCTCCGTCACATTTCAACGAAGCTGAAACTAAATCCACACTTTTGTTCGGAGCACGTGCGAAGACTATCAAGAATGTTGTACAAATCAACGAAGAGCTCACAGCAGAAGAATGGAAACGGCGATATGAGAAAGAAAAAGAGAAGAATACTCGATTGGCCGCCCTTCTCCAGGCAGCGGCTTTGGAACTTTCACGCTGGCGTGCTGGAGAATCAGTGTCTGAGGTTGAATGGGTCAATCTATCAGATTCTGCTCAAATGGCTGTGTCGGAAGTTTCTGGTGGGTCGACTCCACTCATGGAACGTTCGATTGCTCCAGCTCCTCCAATGCTAACTTCTACAACTGGCCCGATCACTGACGAAGAGAAGAAGAAGTACGAAGAGGAACGTGTCAAACTGTATCAGCAACTCGACGAGAAAGATGATGAGATTCAAAAAGTTTCGCAAGAGCTTGAGAAGCTTAGACAACAAGTTCTTCTCCAAGAAGAAGCTTTGGGAACTATGCGTGAAAACGAGGAGCTGATCCGTGAAGAGAACAACCGATTCCAAAAAGAAGCTGAAGACAAGCAGCAAGAAGGAAAGGAAATGATGACAGCTCTGGAAGAGATTGCTGTCAACTTGGATGTTCGACAAGCAGAATGCGAAAAATTGAAGAGAGAGTTGGAAGTTGTTCAAGAAGATAACCAGAGTTTGGAAGATCGAATGAACCAAGCAACATCACTCCTCAATGCTCATCTTGACGAATGTGGTCCAAAAATCCGTCATTTCAAAGAAGGAATCTACAATGTTATTCGTGAATTCAACATTGCTGACATTGCCTCTCAAAATGATCAACTTCCTGATCACGATCTTCTGAACCATGTCAGAATCGGAGTTTCAAAACTCTTCTCAGAATACTCTGCTGCGAAAGAGAGCAGTACAGCTGCCGAGCATGATGCTGAAGCGAAACTTGCAGCTGATGTTGCTCGTGTTGAATCTGGTCAAGACGCGGGTAGAATGAAACAATTGCTGGTGAAGGATCAGGCGGCAAAGGAGATCAAGCCACTAACAGATCGTGTCAATATGGAGCTTACAACGTTGAAGAATTTGAAAAAGGAGTTCATGAGAGTACTTGTTGCTCGATGCCAAGCCAATCAAGACACCGAGGGAGAAGATTCTCTCAGTGGACCAGCTCAAAAGCAACGAATTCAGTTCTTGGAGAACAATTTGGACAAGTTGACGAAGGTTCACAAGCAGgtttgtcgtttttattctcattttgattatcttaaaacttgaattttcagCTTGTTCGCGACAATGCCGATTTGCGCGTTGAACTGCCAAAGATGGAAGCTCGTCTTCGTGGTCGTGAAGATCGCATCAAAATATTAGAAACTGCTCTTCGTGATTCGAAGCAACGTAGTCAAGCAGAACGAAAGAAGTATCAACAAGAAGTTGAACGAATCAAGGAAGCTGTTCGACAACGTAACATGCGACGAATGAATGCTCCACAAATTGTGAAGCCAATCCGTCCAGGACAAGTGTATACGTCTCCGTCAGCAGGAATGTCACAAGGAGCTCCAAATGGCTCAAACGgtgtgtttagtcagacatctacaccttcaacatctcgcaatcagataccatcaaaaatgactatttcacagttgattgcagaaatttaagatttttttaaaaattctttagtgctcatgtaatttttcacaagtaattatactatgaattagaattagagtgagtgtttctttttcttcctaccgtattatcaaatttaacagtcttttgtccgtccatttttcactaatcaaagtttttcagCATAAtgtctcccaacaacaacatcaactcatcgtcttctttgatccaatcaatacactgaagactgacattcaaatgcttctctatctctcttcttttcccggctttgtgatatactttcgatgggcttttctgtttattttaaaatctagtaacttatacaattacgcggcttctggaagtttcaacaaaaatatcttcatttggttggttgtgtctccccatttcgttccttggcttctcgtcttccatgtagaatacaaaacttcaaaagctaaaagtatttaaagcttccctccacccccacccaaattgcctttttccgcctttttgttctaatagtctgtttctatacgattttcctgtttcagttttactaatctgacacgaggttttgtctggttcttccccccgtcacccaccaacactcctatgattgttttttgcatgcgtttgagtgtctttaaagcttgcttgctaaatccccctatcattcttcataagaaatcaacttgtttcgtttctgcacaattcggcccccaaatccccgcacatcccaattg"
    repi_1_aa_sequence = "MDFQNRAGGKTGSGGVASAADAGVDRRERLRQLALETIDLQKDPYFMRNHIGTYECKLCLTLHNNEGSYLAHTQGKKHQANLARRAAKEQSEQPFLPAPQKAAVETKKFVKIGRPGYKVTKERDPGAGQQALLFQIDYPEIADGIAPRHRFMSAYEQKIQPPDKRWQYLLFAAEPYETIGFKIPSREVDKSEKFWTMWNKDTKQFFLQVAFKLERLDDQPYY"
    # amino_acid_sequence = "MEPRTDGAECGVQVFCRIRPLNKTEEKNADRFLPKFPSEDSISLGGKVYVFDKVFKPNTTQEQVYKGAAYHIVQDVLSGYNGTVFAYGQTSSGKTHTMEGVIGDNGLSGIIPRIVADIFNHIYSMDENLQFHIKVSYYEIYNEKIRDLLDPEKVNLSIHEDKNRVPYVKGATERFVGGPDEVLQAIEDGKSNRMVAVTNMNEHSSRSHSVFLITVKQEHQTTKKQLTGKLYLVDLAGSEKVSKTGAQGTVLEEAKNINKSLTALGIVISALAEGTKSHVPYRDSKLTRILQESLGGNSRTTVIICASPSHFNEAETKSTLLFGARAKTIKNVVQINEELTAEEWKRRYEKEKEKNTRLAALLQAAALELSRWRAGESVSEVEWVNLSDSAQMAVSEVSGGSTPLMERSIAPAPPMLTSTTGPITDEEKKKYEEERVKLYQQLDEKDDEIQKVSQELEKLRQQVLLQEEALGTMRENEELIREENNRFQKEAEDKQQEGKEMMTALEEIAVNLDVRQAECEKLKRELEVVQEDNQSLEDRMNQATSLLNAHLDECGPKIRHFKEGIYNVIREFNIADIASQNDQLPDHDLLNHVRIGVSKLFSEYSAAKESSTAAEHDAEAKLAADVARVESGQDAGRMKQLLVKDQAAKEIKPLTDRVNMELTTLKNLKKEFMRVLVARCQANQDTEGEDSLSGPAQKQRIQFLENNLDKLTKVHKQLVRDNADLRVELPKMEARLRGREDRIKILETALRDSKQRSQAERKKYQQEVERIKEAVRQRNMRRMNAPQIVKPIRPGQVYTSPSAGMSQGAPNGSNA"
    cp = CrisprPlanner(repo_1_sense_strand, aa_mutation_site=31, amino_acid_sequence=repi_1_aa_sequence)
    cp.find_recognition_sequence(from_aa=AminoAcid.ARGININE, to_aa=AminoAcid.GLUTAMINE)
    # cp.find_recognition_sequence(aa_mutation_site=26)

work2 = False
if work2:
    # seq = "GCCCCAACAAT"
    # demands = {4: 'C', 5: 'A', 6: 'A'}
    # pam_sites = (6, 8)
    mutants_dic = {}
    CrisprPlanner.modify_seq_to_change_restriction_sites("TCCAACA", {2: "C", 3: "A", 4: "A"},
                                                         mutants=mutants_dic, max_mutations=2, mutations_so_far=0)
    print(mutants_dic)
    print(str(len(mutants_dic)))

work3 = False
if work3:
    mutated_seq = "CCGGACAA"
    CrisprPlanner.find_restriction_sites("TCCGCCAG")


work4 = False
if work4:
    a = "AAA"
    b = AminoAcid.ASPARAGINE
    codon, details = CrisprPlanner.how_to_get_b_from_a(a, b)
    print(codon, str(details))
